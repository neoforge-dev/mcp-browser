This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-07T06:28:19.524Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docker/
  apparmor/
    mcp-browser.profile
  Dockerfile
  xvfb-init.sh
docs/
  examples/
    responsive_testing.py
  api.md
examples/
  event_subscription_example.py
  README.md
mcp-browser/
  docker/
    Dockerfile
  output/
  src/
  tests/
memory-bank/
  .neorules
  active-context.md
  mcp-browser-features.md
  product-context.md
  progress.md
  project-brief.md
  system-patterns.md
  tech-context.md
src/
  __init__.py
  browser_pool.py
  error_handler.py
  integrate_components.py
  integration.py
  main.py
  simple_test.py
  test_api.py
  test_event_subscription.py
  test_events.html
  test_integration.py
  test_lifespan.py
  test_websocket_client.py
  test_websocket.py
test_output/
.dockerignore
.gitignore
.python-version
CHANGELOG.md
docker-compose.yml
Dockerfile
example_mac_mini_setup.md
install_one_line.sh
install.sh
Makefile
ONE_LINE_INSTALL.md
pyproject.toml
README.md
run_analysis.sh
run.sh
simple_test.sh
test_api.sh
test_local.sh
test_mcp_events.sh
test_mcp_tools.sh
test_simple.sh
WEBSOCKET_EVENTS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docker/apparmor/mcp-browser.profile">
#include <tunables/global>

profile mcp-browser flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>
  #include <abstractions/nameservice>
  #include <abstractions/python>
  #include <abstractions/X>

  # Allow network access
  network inet tcp,
  network inet udp,

  # Access to file system
  /app/** r,
  /app/ r,
  /app/main.py r,
  /home/pwuser/ r,
  /home/pwuser/** rw,
  /tmp/** rw,
  /dev/shm/** rw,
  /usr/lib/** rm,
  /usr/bin/** rm,
  /usr/local/bin/python* ix,
  /usr/local/lib/python*/** rm,
  
  # X11 permissions
  /tmp/.X11-unix/** rw,
  owner /dev/tty* rw,
  owner /proc/*/fd/* r,
  owner /var/tmp/** rw,

  # Browser specific
  deny @{PROC}/* r,
  deny @{PROC}/*/net/if_inet6 r,
  deny @{PROC}/*/stat r,
  owner @{PROC}/*/fd/ r,
  owner @{PROC}/*/task/ r,
  owner @{PROC}/*/status r,
  owner @{PROC}/*/cmdline r,
  owner @{PROC}/*/oom_score_adj rw,
  owner @{PROC}/*/task/** r,
}
</file>

<file path="docker/Dockerfile">
FROM mcr.microsoft.com/playwright:v1.51.1-noble

# Setup directories
RUN mkdir -p /home/pwuser/Downloads && \
    chown -R pwuser:pwuser /home/pwuser

# Install uv
RUN curl -fsSL https://astral.sh/uv/install.sh | bash && \
    echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> /home/pwuser/.bashrc

# Set up the application directory
WORKDIR /app

# Copy pyproject.toml first for dependency installation
COPY pyproject.toml .

# Install dependencies using uv
RUN /root/.cargo/bin/uv pip install -e .

# Install Playwright browsers
RUN python -m playwright install chromium

# Create output directory
RUN mkdir -p /app/output && chown -R pwuser:pwuser /app/output

# Copy application files
COPY src/ /app/src/
COPY mcp-browser/ /app/mcp-browser/

# Change ownership of the application to the non-root user
RUN chown -R pwuser:pwuser /app

# Set necessary environment variables
ENV PYTHONUNBUFFERED=1
ENV SERVER_PORT=7665
ENV OUTPUT_DIR=/app/output

# Switch to non-root user
USER pwuser
EXPOSE 7665

# Command to run the application
CMD ["python", "-m", "uv", "run", "src/main.py"]
</file>

<file path="docker/xvfb-init.sh">
#!/bin/bash
set -e
# Log startup message
echo "Starting Xvfb and MCP Browser..."
# Kill any existing Xvfb processes
if [ -f /tmp/.X99-lock ]; then
    echo "Removing existing X11 lock file"
    rm -f /tmp/.X99-lock
fi
# Start Xvfb
Xvfb :99 -screen 0 1280x1024x24 -ac +extension GLX +render -noreset &
XVFB_PID=$!
# Give Xvfb time to start
echo "Waiting for Xvfb to initialize..."
sleep 2
# Check if Xvfb is running
if ! ps -p $XVFB_PID > /dev/null; then
    echo "Error: Xvfb failed to start"
    exit 1
fi
echo "Xvfb started with PID $XVFB_PID"
# Set up a trap to ensure clean shutdown
trap "echo 'Shutting down Xvfb and MCP Browser'; kill $XVFB_PID; exit" SIGINT SIGTERM
# Start the MCP browser application
echo "Starting MCP Browser application..."
cd /app
python3 src/main.py
# If the application exits, also kill Xvfb
kill $XVFB_PID
</file>

<file path="docs/examples/responsive_testing.py">
#!/usr/bin/env python3
"""
Example script demonstrating usage of the MCP Browser Responsive Testing API
"""
import requests
import json
import os
import time
from pprint import pprint
# API settings
API_BASE_URL = "http://localhost:7665"
TEST_URL = "https://example.com"
# Create output directory
output_dir = "responsive_results"
os.makedirs(output_dir, exist_ok=True)
def responsive_test():
    """Test a website for responsive behavior across multiple viewport sizes"""
    print(f"Testing responsive behavior for: {TEST_URL}")
    # Configure test parameters
    viewports = [
        {"width": 375, "height": 667},    # Mobile portrait
        {"width": 768, "height": 1024},   # Tablet portrait
        {"width": 1366, "height": 768},   # Laptop
        {"width": 1920, "height": 1080}   # Desktop
    ]
    selectors = [
        "h1",                # Main heading
        "p",                 # Paragraphs
        "a",                 # Links
        ".container",        # Container elements
        "#main",            # Main content area
    ]
    # Make API request
    try:
        response = requests.post(
            f"{API_BASE_URL}/api/responsive/test",
            json={
                "url": TEST_URL,
                "viewports": viewports,
                "selectors": selectors,
                "include_screenshots": True,
                "compare_elements": True
            }
        )
        # Process response
        if response.status_code == 200:
            result = response.json()
            # Save full results
            timestamp = int(time.time())
            output_file = os.path.join(output_dir, f"responsive_test_{timestamp}.json")
            with open(output_file, "w") as f:
                json.dump(result, f, indent=2)
            print(f"Full results saved to: {output_file}")
            # Display summary
            print("\nResponsive Testing Summary:")
            print("--------------------------")
            print(f"URL: {result['url']}")
            print(f"Tested Viewports: {len(result['viewports'])}")
            # Show viewport-specific metrics
            print("\nViewport Metrics:")
            for vp_result in result['viewport_results']:
                vp_name = vp_result['viewport_name']
                print(f"\n- {vp_name}:")
                if 'page_metrics' in vp_result:
                    metrics = vp_result['page_metrics']
                    print(f"  Document Size: {metrics.get('documentWidth', 'N/A')}x{metrics.get('documentHeight', 'N/A')}")
                    print(f"  Horizontal Scrolling: {'Present' if metrics.get('horizontalScrollPresent', False) else 'None'}")
                    print(f"  Small Touch Targets: {metrics.get('touchTargetSizes', 'N/A')}")
                    print(f"  Media Queries: {len(metrics.get('mediaQueries', []))}")
                if 'screenshot_path' in vp_result:
                    print(f"  Screenshot: {vp_result['screenshot_path']}")
            # Show responsive issues if any
            if result.get('element_comparison'):
                print("\nResponsive Issues Detected:")
                issues_found = False
                for selector, comparison in result['element_comparison'].items():
                    if comparison.get('differences') or comparison.get('responsive_issues'):
                        issues_found = True
                        print(f"\n- {selector}:")
                        for diff in comparison.get('differences', []):
                            print(f"  • {diff.get('description', 'Unknown issue')}")
                            if 'counts' in diff:
                                print(f"    Element counts: {diff['counts']}")
                        for issue in comparison.get('responsive_issues', []):
                            print(f"  • {issue.get('description', 'Unknown issue')}")
                            if 'visibility' in issue:
                                print(f"    Visibility changes: {issue['visibility']}")
                if not issues_found:
                    print("No significant responsive issues detected.")
            return True
        else:
            print(f"Error: API returned status code {response.status_code}")
            print(response.text)
            return False
    except Exception as e:
        print(f"Error: {e}")
        return False
if __name__ == "__main__":
    responsive_test()
</file>

<file path="docs/api.md">
# MCP Browser API Documentation

## Frontend Analysis Endpoints

### Screenshot Capture

**Endpoint:** `POST /api/screenshots/capture`

Captures a screenshot of a web page with configurable options.

**Parameters:**
- `url` (string, required): The URL of the page to capture
- `viewport` (object, optional): The viewport size, default: `{"width": 1280, "height": 800}`
- `full_page` (boolean, optional): Whether to capture the full page or just the viewport, default: `true`
- `format` (string, optional): Image format, options: "png" or "jpeg", default: "png"
- `quality` (integer, optional): Image quality for JPEG format (1-100), default: None
- `wait_until` (string, optional): When to consider navigation finished, default: "networkidle"

**Example Request:**
```json
{
  "url": "https://example.com",
  "viewport": {
    "width": 1920,
    "height": 1080
  },
  "full_page": true,
  "format": "png",
  "wait_until": "networkidle"
}
```

**Example Response:**
```json
{
  "success": true,
  "screenshot": "base64_encoded_image_data...",
  "format": "png",
  "viewport": {
    "width": 1920,
    "height": 1080
  },
  "url": "https://example.com"
}
```

### DOM Extraction

**Endpoint:** `POST /api/dom/extract`

Extracts DOM elements from a web page with optional style computation.

**Parameters:**
- `url` (string, required): The URL of the page to analyze
- `selector` (string, optional): CSS selector for elements to extract, if not provided extracts entire DOM
- `include_styles` (boolean, optional): Whether to include computed styles, default: `false`
- `include_attributes` (boolean, optional): Whether to include element attributes, default: `true`

**Example Request:**
```json
{
  "url": "https://example.com",
  "selector": "h1",
  "include_styles": true,
  "include_attributes": true
}
```

**Example Response:**
```json
{
  "success": true,
  "url": "https://example.com",
  "dom": [
    {
      "tagName": "h1",
      "textContent": "Example Domain",
      "isVisible": true,
      "boundingBox": {
        "x": 192,
        "y": 192,
        "width": 896,
        "height": 38
      },
      "attributes": {
        "class": "heading"
      },
      "styles": {
        "color": "rgb(0, 0, 0)",
        "font-size": "32px",
        "margin": "0px"
      }
    }
  ]
}
```

### CSS Analysis

**Endpoint:** `POST /api/css/analyze`

Analyzes CSS properties of selected elements on a web page.

**Parameters:**
- `url` (string, required): The URL of the page to analyze
- `selector` (string, required): CSS selector for elements to analyze
- `properties` (array, optional): Specific CSS properties to analyze, if not provided returns most common properties
- `check_accessibility` (boolean, optional): Whether to include accessibility checks, default: `false`

**Example Request:**
```json
{
  "url": "https://example.com",
  "selector": "p",
  "properties": ["color", "font-size", "margin", "padding"],
  "check_accessibility": true
}
```

**Example Response:**
```json
{
  "success": true,
  "url": "https://example.com",
  "selector": "p",
  "elements": [
    {
      "tagName": "p",
      "textContent": "This domain is for use in illustrative examples in documents.",
      "isVisible": true,
      "boundingBox": {
        "x": 192,
        "y": 240,
        "width": 896,
        "height": 72
      },
      "styles": {
        "color": "rgb(0, 0, 0)",
        "font-size": "16px",
        "margin": "16px 0px",
        "padding": "0px"
      },
      "accessibility": {
        "colorContrast": null,
        "hasAltText": null,
        "hasAriaLabel": false,
        "isFocusable": false,
        "backgroundColor": "rgb(255, 255, 255)",
        "textColor": "rgb(0, 0, 0)"
      }
    }
  ],
  "count": 1
}
```

### Accessibility Testing

**Endpoint:** `POST /api/accessibility/test`

Tests a web page for accessibility issues using axe-core.

**Parameters:**
- `url` (string, required): The URL of the page to test
- `standard` (string, optional): Accessibility standard to test against, options: "wcag2a", "wcag2aa", "wcag2aaa", "wcag21aa", "section508", default: "wcag2aa"
- `include_html` (boolean, optional): Whether to include HTML context in results, default: `true`
- `include_warnings` (boolean, optional): Whether to include warnings in results, default: `true`
- `selectors` (array, optional): List of CSS selectors to test, if not provided tests the entire page

**Example Request:**
```json
{
  "url": "https://example.com",
  "standard": "wcag2aa",
  "include_html": true,
  "include_warnings": true,
  "selectors": ["main", "nav"]
}
```

**Example Response:**
```json
{
  "url": "https://example.com",
  "timestamp": 1742762305,
  "standard": "wcag2aa",
  "results": {
    "testEngine": {
      "name": "axe-core",
      "version": "4.7.0"
    },
    "violations": [
      {
        "id": "color-contrast",
        "impact": "serious",
        "nodes": [
          {
            "html": "<p style=\"color: #999\">Low contrast text</p>",
            "target": ["p:nth-child(2)"],
            "failureSummary": "Element has insufficient color contrast"
          }
        ]
      }
    ],
    "passes": [...],
    "incomplete": [...],
    "inapplicable": [...]
  },
  "output_file": "output/accessibility_test_1742762305.json"
}
```

### Responsive Design Testing

**Endpoint:** `POST /api/responsive/test`

Tests a web page across different viewport sizes to analyze responsive behavior.

**Parameters:**
- `url` (string, required): The URL of the page to test
- `viewports` (array, optional): List of viewport sizes to test, default:
  ```
  [
    {"width": 375, "height": 667},   # Mobile
    {"width": 768, "height": 1024},  # Tablet
    {"width": 1366, "height": 768},  # Laptop
    {"width": 1920, "height": 1080}  # Desktop
  ]
  ```
- `compare_elements` (boolean, optional): Whether to compare elements across viewports, default: `true`
- `include_screenshots` (boolean, optional): Whether to capture screenshots at each viewport, default: `true`
- `selectors` (array, optional): List of CSS selectors to test, required for element comparison
- `waiting_time` (integer, optional): Additional time to wait after page load in milliseconds, default: `null`

**Example Request:**
```json
{
  "url": "https://example.com",
  "viewports": [
    {"width": 375, "height": 667},
    {"width": 1366, "height": 768}
  ],
  "selectors": ["h1", "p", ".navigation"],
  "include_screenshots": true,
  "compare_elements": true
}
```

**Example Response:**
```json
{
  "url": "https://example.com",
  "timestamp": 1742762418,
  "viewports": [
    {"width": 375, "height": 667},
    {"width": 1366, "height": 768}
  ],
  "viewport_results": [
    {
      "viewport": {"width": 375, "height": 667},
      "viewport_name": "375x667",
      "page_metrics": {
        "documentWidth": 375,
        "documentHeight": 667,
        "viewportWidth": 375,
        "viewportHeight": 667,
        "mediaQueries": ["(max-width: 768px)"],
        "horizontalScrollPresent": false,
        "textOverflows": 0,
        "touchTargetSizes": 2
      },
      "elements_data": [...],
      "screenshot_path": "output/responsive/1742762418/screenshot_375x667.png"
    },
    {
      "viewport": {"width": 1366, "height": 768},
      "viewport_name": "1366x768",
      "page_metrics": {...},
      "elements_data": [...],
      "screenshot_path": "output/responsive/1742762418/screenshot_1366x768.png"
    }
  ],
  "element_comparison": {
    "h1": {
      "selector": "h1",
      "differences": [],
      "responsive_issues": []
    },
    "p": {
      "selector": "p",
      "differences": [],
      "responsive_issues": [
        {
          "element_key": "p-0",
          "issue": "visibility_change",
          "description": "Element visibility changes across viewports",
          "visibility": {
            "375x667": false,
            "1366x768": true
          }
        }
      ]
    }
  },
  "output_directory": "output/responsive/1742762418"
}
```

## WebSocket Interface

The MCP Browser provides a WebSocket interface for real-time communication with the browser.

**Endpoint:** `WebSocket /ws`

**Supported Actions:**
- `navigate`: Navigate to a URL
  ```json
  {
    "action": "navigate",
    "url": "https://example.com"
  }
  ```
</file>

<file path="examples/event_subscription_example.py">
#!/usr/bin/env python3
"""
MCP Browser WebSocket Event Subscription Example
This example demonstrates how to:
1. Connect to the MCP Browser WebSocket event endpoint
2. Subscribe to specific browser events
3. Process and handle the events in real-time
4. Unsubscribe when no longer needed
Requirements:
- websockets
- asyncio
- json
Usage:
python event_subscription_example.py
"""
import asyncio
import json
import signal
import sys
import time
import argparse
from uuid import uuid4
import websockets
# Default configuration
DEFAULT_WS_URL = "ws://localhost:7665/ws/browser/events"
DEFAULT_API_URL = "http://localhost:7665"
DEFAULT_TEST_URL = "https://example.com"
DEFAULT_TIMEOUT = 60  # seconds
# Event colors for terminal output
COLORS = {
    "PAGE": "\033[94m",    # Blue
    "DOM": "\033[92m",     # Green
    "CONSOLE": "\033[93m", # Yellow
    "NETWORK": "\033[91m", # Red
    "DEFAULT": "\033[0m",  # Reset
}
class EventSubscriptionClient:
    def __init__(self, ws_url, timeout=60):
        self.ws_url = ws_url
        self.timeout = timeout
        self.subscriptions = {}
        self.running = False
        self.websocket = None
        self.client_id = None
    async def connect(self):
        """Connect to the WebSocket server"""
        try:
            self.websocket = await websockets.connect(self.ws_url)
            print(f"Connected to {self.ws_url}")
            # Wait for the welcome message
            welcome = await self.websocket.recv()
            welcome_data = json.loads(welcome)
            if welcome_data.get("type") == "connection":
                self.client_id = welcome_data.get("client_id")
                print(f"Received welcome message: {welcome_data.get('message')}")
                print(f"Client ID: {self.client_id}")
            # Set a timeout handler
            if self.timeout > 0:
                asyncio.create_task(self._timeout_handler())
            return True
        except Exception as e:
            print(f"Connection error: {e}")
            return False
    async def subscribe(self, event_types, filters=None):
        """Subscribe to specific event types with optional filters"""
        if not self.websocket:
            print("Not connected. Call connect() first.")
            return None
        subscription_request = {
            "action": "subscribe",
            "event_types": event_types
        }
        if filters:
            subscription_request["filters"] = filters
        await self.websocket.send(json.dumps(subscription_request))
        response = await self.websocket.recv()
        response_data = json.loads(response)
        if "subscription_id" in response_data:
            subscription_id = response_data["subscription_id"]
            self.subscriptions[subscription_id] = {
                "event_types": event_types,
                "filters": filters
            }
            print(f"Subscribed to {', '.join(event_types)} with ID: {subscription_id}")
            return subscription_id
        else:
            print(f"Subscription failed: {response_data}")
            return None
    async def unsubscribe(self, subscription_id):
        """Unsubscribe from a specific subscription"""
        if not self.websocket:
            print("Not connected. Call connect() first.")
            return False
        if subscription_id not in self.subscriptions:
            print(f"Subscription ID {subscription_id} not found.")
            return False
        unsubscribe_request = {
            "action": "unsubscribe",
            "subscription_id": subscription_id
        }
        await self.websocket.send(json.dumps(unsubscribe_request))
        response = await self.websocket.recv()
        response_data = json.loads(response)
        if response_data.get("success", False):
            del self.subscriptions[subscription_id]
            print(f"Unsubscribed from {subscription_id}")
            return True
        else:
            print(f"Unsubscribe failed: {response_data}")
            return False
    async def list_subscriptions(self):
        """List all active subscriptions"""
        if not self.websocket:
            print("Not connected. Call connect() first.")
            return []
        list_request = {
            "action": "list"
        }
        await self.websocket.send(json.dumps(list_request))
        response = await self.websocket.recv()
        response_data = json.loads(response)
        if "subscriptions" in response_data:
            return response_data["subscriptions"]
        else:
            print(f"List subscriptions failed: {response_data}")
            return []
    async def listen(self):
        """Listen for events and process them"""
        if not self.websocket:
            print("Not connected. Call connect() first.")
            return
        self.running = True
        try:
            while self.running:
                message = await self.websocket.recv()
                event = json.loads(message)
                # Only process events with a proper type
                if "type" in event and event["type"] not in ["connection", "subscription"]:
                    self._process_event(event)
        except websockets.exceptions.ConnectionClosed:
            print("Connection closed")
        except Exception as e:
            print(f"Error in listen loop: {e}")
        finally:
            self.running = False
    def _process_event(self, event):
        """Process a received event"""
        event_type = event.get("type", "UNKNOWN")
        event_name = event.get("event", "unknown")
        timestamp = event.get("timestamp", time.time())
        # Format timestamp
        time_str = time.strftime("%H:%M:%S", time.localtime(timestamp))
        # Get color for event type
        color = COLORS.get(event_type, COLORS["DEFAULT"])
        reset = COLORS["DEFAULT"]
        # Print event information
        print(f"{color}[{time_str}] {event_type}.{event_name}{reset}")
        # Print event data
        if "data" in event:
            data_str = json.dumps(event["data"], indent=2)
            print(f"  Data: {data_str}")
        # Print page ID if available
        if "page_id" in event:
            print(f"  Page: {event['page_id']}")
        print("-" * 40)
    async def close(self):
        """Close the WebSocket connection"""
        self.running = False
        if self.websocket:
            await self.websocket.close()
            self.websocket = None
            print("Connection closed")
    async def _timeout_handler(self):
        """Handle timeout to automatically close the connection"""
        await asyncio.sleep(self.timeout)
        if self.running:
            print(f"Timeout after {self.timeout} seconds")
            await self.close()
async def navigate_to_page(api_url, url):
    """Navigate the browser to a specific URL using the API"""
    import aiohttp
    navigate_url = f"{api_url}/api/browser/navigate?url={url}"
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(navigate_url) as response:
                result = await response.json()
                if result.get("success", False):
                    print(f"Successfully navigated to: {url}")
                else:
                    print(f"Navigation failed: {result}")
    except Exception as e:
        print(f"Navigation error: {e}")
        print("Continuing without navigation...")
async def main():
    parser = argparse.ArgumentParser(description="MCP Browser WebSocket Event Subscription Example")
    parser.add_argument("--ws-url", default=DEFAULT_WS_URL, help="WebSocket URL")
    parser.add_argument("--api-url", default=DEFAULT_API_URL, help="API URL")
    parser.add_argument("--test-url", default=DEFAULT_TEST_URL, help="URL to navigate to")
    parser.add_argument("--timeout", type=int, default=DEFAULT_TIMEOUT, help="Timeout in seconds")
    args = parser.parse_args()
    # Extract the base URL from the WebSocket URL to use for API calls if not specified
    if args.ws_url and args.ws_url.startswith("ws://") and "--api-url" not in sys.argv:
        ws_parts = args.ws_url.split("/")
        if len(ws_parts) >= 3:
            args.api_url = f"http://{ws_parts[2]}"
            print(f"Using API URL derived from WebSocket URL: {args.api_url}")
    # Setup signal handlers
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, lambda: asyncio.create_task(shutdown(client)))
    # Create client
    client = EventSubscriptionClient(args.ws_url, args.timeout)
    # Connect to WebSocket server
    if not await client.connect():
        return 1
    # Subscribe to events
    subscription_id = await client.subscribe([
        "PAGE", "NETWORK", "CONSOLE", "DOM"
    ])
    if not subscription_id:
        await client.close()
        return 1
    # Navigate to test URL to generate events
    print(f"Navigating to {args.test_url}...")
    await navigate_to_page(args.api_url, args.test_url)
    # Listen for events
    print("Listening for events. Press Ctrl+C to exit.")
    await client.listen()
    # Cleanup
    await client.close()
    return 0
async def shutdown(client):
    """Shutdown gracefully"""
    print("Shutting down...")
    await client.close()
    tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
    [task.cancel() for task in tasks]
    await asyncio.gather(*tasks, return_exceptions=True)
    asyncio.get_event_loop().stop()
if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
</file>

<file path="examples/README.md">
# MCP Browser Examples

This directory contains example scripts and applications that demonstrate how to use various features of the MCP Browser.

## Available Examples

### 1. WebSocket Event Subscription

**File:** `event_subscription_example.py`

This example demonstrates how to use the WebSocket event subscription feature to receive real-time browser events. The script:

- Connects to the MCP Browser WebSocket events endpoint
- Subscribes to specific event types (PAGE, NETWORK, CONSOLE, DOM)
- Navigates to a test URL to generate events
- Receives and displays browser events in real-time
- Handles graceful shutdown and cleanup

**Usage:**

```bash
# Run with default settings
python event_subscription_example.py

# Or customize with options
python event_subscription_example.py --ws-url ws://localhost:7665/ws/browser/events --test-url https://example.com --timeout 120
```

**Command-line Options:**

- `--ws-url`: WebSocket URL (default: ws://localhost:7665/ws/browser/events)
- `--api-url`: API URL (default: http://localhost:7665)
- `--test-url`: URL to navigate to (default: https://example.com)
- `--timeout`: Timeout in seconds (default: 60)

**Requirements:**

- websockets
- asyncio
- aiohttp
- json

Install with:
```bash
pip install websockets aiohttp
```

## Running the Examples

Before running any examples, make sure the MCP Browser server is running:

```bash
# Go to the MCP Browser root directory
cd /path/to/mcp-browser

# Start the server
python src/main.py
```

Then, in a separate terminal, you can run any of the examples as described above.

## Creating Your Own Examples

Feel free to use these examples as a starting point for your own applications. The key patterns demonstrated include:

1. **API Interaction**: How to call the HTTP API endpoints
2. **WebSocket Communication**: How to establish WebSocket connections and handle messages
3. **Event Subscription**: How to subscribe to browser events and process them
4. **Error Handling**: How to handle errors and gracefully shutdown
</file>

<file path="mcp-browser/docker/Dockerfile">
FROM mcr.microsoft.com/playwright:v1.51.1-noble
</file>

<file path="memory-bank/.neorules">
# NEO Rules for MCP Browser Project

## Project-Specific Patterns

1. **Docker-First Development**
   - Always test changes in Docker environment before committing
   - Use volume mounts for local development to speed up iteration
   - Keep Docker images slim by using multi-stage builds where appropriate

2. **Security Considerations**
   - Never run browser processes as root
   - Always use environment variables for secrets
   - Apply AppArmor profiles for all containers
   - Validate and sanitize all user inputs
   - Use virtual display server (Xvfb) for isolation

3. **Python Best Practices**
   - Use async/await for all IO operations
   - Type hint all functions for better IDE support
   - Use dataclasses for structured data
   - Prefer composition over inheritance
   - Use dependency injection for testability

4. **Playwright Usage Patterns**
   - Create isolated browser contexts for each session
   - Handle browser errors with structured error types
   - Use page.evaluate sparingly for better performance
   - Manage browser resources carefully (close pages when done)
   - Use stealth mode for more realistic browser behavior
   - Access browser_context.pages as a property, not a method (no await needed)
   - Always check if pages exist before accessing them
   - Handle parameters differently for element methods vs page methods

5. **MCP Protocol Extensions**
   - Follow existing MCP patterns for tool definitions
   - Return structured JSON for all responses
   - Use WebSockets for real-time events
   - Include metadata with all responses (timing, etc.)
   - Namespace browser-specific tools appropriately
   - Use consistent error handling with try/except blocks
   - Implement proper page navigation and lifecycle management
   - Use descriptive error messages for easier debugging

## User Preferences

1. **Code Organization**
   - Module structure: src/[module]/[feature].py
   - Test structure: tests/[module]/test_[feature].py
   - Separation of UI, business logic, and data access
   - Configuration via environment variables, not files
   - Documentation in Markdown format

2. **Testing Approach**
   - Unit tests for all core functionality
   - Integration tests for API endpoints
   - Browser tests run in a similar container environment
   - Mocking external dependencies for unit tests
   - Test coverage target: 80%+
   - Use test scripts for API endpoint verification
   - Save test results to output directory for later inspection

3. **Documentation Style**
   - RESTful API documented with OpenAPI
   - Code comments focus on "why" not "what"
   - README-driven development (write docs first)
   - Example scripts for common operations
   - Architecture diagrams in ASCII format for version control

4. **Deployment Preferences**
   - One-command deployment with Docker Compose
   - Environment-specific configuration via .env files
   - Health checks for all services
   - Graceful shutdown handling
   - Automatic restart capabilities

## Known Project Challenges

1. **Resource Management**
   - Browser automation can be memory-intensive
   - Monitor and adjust container resource limits
   - Consider pooling browser instances for efficiency
   - Implement garbage collection for abandoned sessions

2. **Cross-Platform Compatibility**
   - Local development on macOS, deployment on Linux
   - Xvfb doesn't work the same on all platforms
   - Use Docker to normalize environments
   - Document platform-specific quirks

3. **Security Balancing**
   - Need security, but also need browser functionality
   - AppArmor profiles need careful configuration
   - Balance between isolation and capabilities
   - Regular security scanning for dependencies

4. **Browser Automation Flakiness**
   - Handle intermittent failures gracefully
   - Implement retry mechanisms where appropriate
   - Add detailed logging for debugging
   - Use stable selectors for DOM elements

5. **Performance Considerations**
   - Browser startup time impacts user experience
   - Consider browser pooling for improved responsiveness
   - Optimize Docker image size for faster deployment
   - Cache Playwright browser downloads

## Learned Solutions

1. **Problem**: Xvfb doesn't work properly on macOS for local testing
   **Solution**: Use PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1 environment variable and run in headless-only mode for local development on macOS

2. **Problem**: Docker container restart fails to clean up Xvfb processes
   **Solution**: Add trap handlers in xvfb-init.sh script to kill processes on exit signals

3. **Problem**: Playwright browser download is slow
   **Solution**: Use a specific browser (chromium only) instead of all browsers, and consider caching the download in a Docker volume

4. **Problem**: WebSocket connections terminate unexpectedly
   **Solution**: Implement ping/pong mechanism to keep connections alive and detect disconnections

5. **Problem**: Resource limits too restrictive
   **Solution**: Start with conservative limits and monitor actual usage, then adjust accordingly based on real-world metrics

6. **Problem**: JavaScript booleans in Playwright page.evaluate()
   **Solution**: Convert Python boolean values (True/False) to JavaScript boolean values (true/false) using str().lower() when injecting into JavaScript code

7. **Problem**: Complex DOM extraction and analysis
   **Solution**: Use f-strings to inject parameters into JavaScript functions rather than passing them as arguments to Playwright's evaluate method, which can be error-prone for complex structures

8. **Problem**: API testing and verification
   **Solution**: Create dedicated test endpoints that verify all API functionality, save results to output files, and provide detailed error reporting for easier debugging

9. **Problem**: Output file organization
   **Solution**: Create separate directories for each API output type (screenshots, DOM data, CSS analysis, etc.) and use timestamps in filenames to avoid conflicts

10. **Problem**: Cross-viewport testing
    **Solution**: Test responsive behavior by rendering the same page at different viewport sizes and comparing element properties and visibility

11. **Problem**: browser_context.pages access error "object list can't be used in 'await' expression"
    **Solution**: Access browser_context.pages as a property, not awaitable method. Use "pages = browser_context.pages" instead of "pages = await browser_context.pages"

12. **Problem**: Element screenshot with full_page parameter error
    **Solution**: Element screenshots don't support the full_page parameter. Use different parameter sets for page.screenshot() and element.screenshot()

13. **Problem**: Browser page initialization
    **Solution**: Always check if any pages exist before accessing them. Create a new page if none exist during navigation, handle empty page list gracefully in other endpoints

14. **Problem**: API query parameter handling vs body parameter handling
    **Solution**: For GET requests, use query parameters. For POST requests that need both URL and body parameters, support both input methods with clear parameter names 

## WebSocket Event Handling Patterns

1. **Separate Connection Management**: Keep WebSocket connections in separate collections based on their purpose.
   - `active_connections` for general control connections
   - `event_connections` for event subscription connections

2. **Unique Identifiers for Subscriptions**: Use unique identifiers for subscriptions with a descriptive prefix (e.g., `sub_` prefix for subscription IDs) to make them easily identifiable.

3. **Event Filtering Architecture**: Implement filtering as a separate function (`_matches_filters`) to allow flexible extension of filtering criteria.
   - URL pattern matching with regex
   - Page ID exact matching
   - Can be extended with additional filter types

4. **Broadcasting Strategy**: Use an async broadcast function that filters events before sending them to clients, avoiding unnecessary processing and network usage.

5. **Event Type Enumeration**: Use Enums for event types and event names to enforce consistency, make code more readable, and enable static checking.

6. **Subscription Handler Pattern**: Use a dictionary of event types to handler functions for dynamic event handling registration and unregistration.

7. **Client Message Structure**: For WebSocket client messages, use an "action" field to distinguish between different operations (subscribe, unsubscribe, list).

8. **Connection and Subscription Lifecycle**: 
   - Add connections to the active pool on connect
   - Remove connections and their subscriptions on disconnect
   - Send confirmation messages for subscription events
   - Handle errors gracefully with appropriate error messages
   
9. **Event Data Structure**: Include consistent fields in all events:
   - `type`: The event type (PAGE, DOM, CONSOLE, NETWORK)
   - `event`: Specific event name (e.g., "page.load", "console.error")
   - `timestamp`: When the event occurred
   - `data`: Event-specific details
   - `page_id`: (when applicable) Identifier for the source page

## API Endpoint Conventions

// ... existing code ...

## Response Formats

// ... existing code ...

## Testing and Debugging

// ... existing code ...

## File Organization

// ... existing code ...
</file>

<file path="memory-bank/active-context.md">
# Active Context - MCP Browser Project

## Current Focus

We have successfully installed and configured MCP Browser with the browser visualization system, after addressing issues with the XQuartz display server. 

Our current focus is on:

1. **Installation Script Cleanup**: We have multiple redundant installation scripts that need consolidation.
2. **Resource Management Improvements**: Implement browser resource pooling and memory optimization.
3. **Enhanced Documentation**: Further improve API documentation with examples.
4. **Security Enhancements**: Strengthen security with network isolation and rate limiting.

## Latest Changes

- Fixed issues with XQuartz integration in the installation scripts
- Created a more robust approach to launching X11 server during installation
- Successfully deployed and tested the MCP Browser
- Added WebSocket event subscription models and event type definitions
- Implemented global event subscription management and broadcasting
- Created a WebSocket endpoint for browser events at `/ws/browser/events`
- Added API endpoints for subscription management (subscribe, unsubscribe, list)
- Added event filtering functionality by URL pattern and page ID
- Fixed WebSocket event subscription to handle missing dependencies gracefully

## Development Summary (March 24, 2025)

Today we accomplished:

1. **Installation Script Debugging**:
   - Identified and fixed issues with XQuartz display server startup
   - Created a simplified installation script that works with pre-started X11
   - Successfully completed installation on Mac Mini
   - Documented the installation process and fixes

2. **Script Cleanup Required**:
   - We need to consolidate multiple redundant installation scripts
   - Current redundant scripts include:
     - `install_one_line.sh`: One-line installation launcher
     - `install_mcp_browser.sh`: Main installer script
     - `install_helper.sh`: Helper to fix line endings and XQuartz issues
     - `simple_install.sh`: Simplified installer that skips XQuartz setup
   - We should keep only the essential scripts and update documentation

## Active Decisions

1. **Installation Script Cleanup**: We'll consolidate the installation scripts into:
   - One main installer script with robust error handling
   - A one-line launcher that properly handles all edge cases
   - Update documentation to reflect these changes

2. **XQuartz Integration Strategy**: Rather than trying different approaches to launch XQuartz, we'll:
   - Check if XQuartz/X11 is already running first
   - Try direct binary execution if not running
   - Fall back to app launching only as a last resort
   - Add clear error messages and documentation for troubleshooting

3. **API Design**: The RESTful API approach with WebSocket support is working well. Continuing with this pattern for remaining endpoints.

4. **Page Lifecycle Management**: Currently creating and destroying pages for each request. Considering implementing a page pool for better performance, especially under high load.

5. **Error Handling Strategy**: We've established a consistent pattern using try-except blocks with structured error responses. Need to formalize this into a reusable utility.

6. **Testing Approach**: The current test script works well for basic API validation. Need to decide on a more comprehensive testing framework (pytest, etc.) for more complex tests.

7. **Security Model**: Evaluating security requirements and implementation strategies, including AppArmor profiles, network isolation, and rate limiting.

8. **Performance Optimization**: Considering strategies for optimizing browser performance, particularly in container environments with resource constraints.

9. **Monitoring Strategy**: Evaluating monitoring tools and approaches, with a focus on real-time metrics, log aggregation, and alerting.

10. **Developer Experience**: Considering approaches to enhance developer experience, including API documentation, CLI tools, and example scripts.

11. **Browser Context Management**: Implementing browser context management so pages can be properly accessed and handled without synchronization issues.

12. **Using separate WebSocket endpoints for different features**:
    - `/ws` for general communication
    - `/ws/browser/events` for event subscriptions
    
13. **Event subscriptions are managed per client connection with unique IDs**:
    - We've implemented a broadcasting mechanism that filters events based on subscription criteria
    
14. **Using JSON for all WebSocket communication for consistency and ease of debugging**

15. **Using graceful fallbacks for optional dependencies**: Implemented try-except patterns for optional dependencies like colorama to ensure core functionality works regardless of environment setup.

16. **Aligning WebSocket URLs and port configurations**: Standardized WebSocket endpoint paths and port configurations across Docker, test scripts, and server code to ensure seamless communication.

## Open Questions

1. **Should we implement a separate authentication mechanism for WebSocket connections?**
   
2. **How should we handle reconnection logic for clients that disconnect temporarily?**
   
3. **What's the optimal approach for scaling the event broadcasting system for many simultaneous connections?**
   
4. **Should we implement event batching for high-frequency events to avoid overwhelming clients?**

## Current Blockers

1. **Script Proliferation**: Too many redundant scripts causing confusion and maintenance issues.

2. **Resource Management**: Need to implement proper resource management for browser instances to prevent memory leaks and resource exhaustion.

3. **Browser Compatibility**: Need to ensure compatibility with different browser versions and configurations.

4. **Testing Environment**: Need to establish a suitable testing environment for browser automation and visual testing.

## Current Sprint Goals

1. ~~Complete the core API implementation for frontend analysis (screenshot, DOM, CSS, accessibility, responsive)~~ ✅ COMPLETED
2. ~~Implement basic MCP protocol extensions~~ ✅ COMPLETED 
3. ~~Implement WebSocket event subscriptions~~ ✅ COMPLETED
4. ~~Fix installation script issues with XQuartz integration~~ ✅ COMPLETED
5. Clean up redundant scripts and consolidate into essential ones
6. Enhance resource management with page pooling
7. Implement verification agent functionality
8. Set up comprehensive testing framework with good test coverage
9. Enhance documentation with API usage examples
10. Implement proper error handling and resource management
</file>

<file path="memory-bank/mcp-browser-features.md">
# MCP Browser - Feature Implementation Plan

## 1. Frontend Analysis Capabilities

### 1.1 Screenshot Capture and Comparison

**Implementation Tasks:**
- Implement screenshot capture API endpoint
- Add viewport size configuration
- Create screenshot comparison utility
- Develop visual diff highlighting
- Implement pixel-based comparison metrics
- Add structural similarity index metrics
- Create screenshot storage and retrieval

**API Design:**
```python
@app.post("/api/screenshots/capture")
async def capture_screenshot(
    url: str, 
    viewport: dict = {"width": 1280, "height": 800},
    full_page: bool = True,
    format: str = "png",
    quality: Optional[int] = None,
    wait_until: str = "networkidle"
):
    """Capture a screenshot of a web page"""
    # Implementation
```

```python
@app.post("/api/screenshots/compare")
async def compare_screenshots(
    screenshot1_id: str,
    screenshot2_id: str,
    threshold: float = 0.1,
    highlight_diff: bool = True
):
    """Compare two screenshots and return diff metrics"""
    # Implementation
```

### 1.2 DOM State Analysis

**Implementation Tasks:**
- Implement DOM tree extraction
- Create element selector utilities
- Develop DOM comparison tools
- Add accessibility checking
- Implement CSS property extraction
- Create DOM search functionality
- Add viewport-specific DOM analysis

**API Design:**
```python
@app.post("/api/dom/extract")
async def extract_dom(
    url: str,
    selector: Optional[str] = None,
    include_styles: bool = False,
    include_attributes: bool = True
):
    """Extract DOM elements from a web page"""
    # Implementation
```

```python
@app.post("/api/dom/compare")
async def compare_dom(
    dom1_id: str,
    dom2_id: str,
    ignore_attributes: List[str] = ["id", "data-testid"]
):
    """Compare two DOM states and identify differences"""
    # Implementation
```

### 1.3 CSS Analysis

**Implementation Tasks:**
- Extract computed CSS properties for elements
- Analyze responsive design breakpoints
- Verify CSS consistency
- Check color contrast for accessibility
- Validate font sizes and readability
- Detect layout shifts and overflow issues

**API Design:**
```python
@app.post("/api/css/analyze")
async def analyze_css(
    url: str,
    selector: str,
    properties: Optional[List[str]] = None,
    check_accessibility: bool = False
):
    """Analyze CSS properties for selected elements"""
    # Implementation
```

### 1.4 Accessibility Analysis

**Implementation Tasks:**
- ✅ Implement accessibility testing API endpoint
- ✅ Add multiple standards support (WCAG, Section 508)
- ✅ Create selectors-based testing capability
- ✅ Add detailed violation reporting
- ✅ Implement HTML context inclusion for better debugging
- Add summary report generation
- Develop custom rule support

**API Design:**
```python
@app.post("/api/accessibility/test")
async def test_accessibility(
    url: str,
    standard: str = "wcag2aa",
    include_html: bool = True,
    include_warnings: bool = True,
    selectors: Optional[List[str]] = None
):
    """Test a web page for accessibility issues"""
    # Implementation
```

```python
@app.post("/api/accessibility/summary")
async def accessibility_summary(
    url: str,
    standards: List[str] = ["wcag2aa"],
    viewport_sizes: List[Dict[str, int]] = None
):
    """Generate a comprehensive accessibility summary across standards and viewport sizes"""
    # Implementation
```

### 1.5 Responsive Design Testing

**Implementation Tasks:**
- ✅ Create viewport size simulation
- ✅ Implement cross-device testing
- ✅ Add element visibility checking across viewports
- ✅ Develop media query detection
- ✅ Implement touch target size validation
- ✅ Create comparison mode for detecting responsive differences
- Add advanced layout shift detection

**API Design:**
```python
@app.post("/api/responsive/test")
async def test_responsive(
    url: str,
    viewports: List[Dict[str, int]] = None,
    selectors: Optional[List[str]] = None,
    include_screenshots: bool = True,
    compare_elements: bool = True
):
    """Test a web page across different viewport sizes"""
    # Implementation
```

```python
@app.post("/api/responsive/compare")
async def compare_responsive(
    url: str,
    device_presets: List[str] = ["mobile", "tablet", "desktop"],
    scenarios: List[Dict] = None
):
    """Compare a web page across different device presets with custom scenarios"""
    # Implementation
```

## 2. MCP Protocol Extensions

### 2.1 Browser-Specific MCP Tools

**Implementation Tasks:**
- Create MCP tool for browser navigation
- Implement page interaction tools (click, type, etc.)
- Develop DOM interaction tools
- Add screenshot and visual tools
- Create form interaction tools
- Implement browser automation tools

**API Design:**
```python
@mcp.tool()
async def browser_navigate(url: str, wait_until: str = "networkidle") -> Dict[str, Any]:
    """
    Navigate the browser to a URL
    
    Args:
        url: The URL to navigate to
        wait_until: Navigation condition to wait for
    
    Returns:
        Dictionary with navigation results
    """
    # Implementation
```

```python
@mcp.tool()
async def browser_click(selector: str, timeout: int = 30000) -> Dict[str, Any]:
    """
    Click an element on the page
    
    Args:
        selector: CSS selector for the element
        timeout: Maximum time to wait for element in ms
    
    Returns:
        Dictionary with click results
    """
    # Implementation
```

### 2.2 DOM Manipulation Tools

**Implementation Tasks:**
- Create element selection tools
- Implement form filling utilities
- Develop DOM traversal capabilities
- Add element property extraction
- Implement DOM modification tools
- Create shadow DOM handling utilities

**API Design:**
```python
@mcp.tool()
async def dom_extract(selector: str, include_html: bool = True) -> Dict[str, Any]:
    """
    Extract information about DOM elements
    
    Args:
        selector: CSS selector for elements to extract
        include_html: Whether to include HTML content
    
    Returns:
        Dictionary with DOM element data
    """
    # Implementation
```

### 2.3 Visual Analysis Tools

**Implementation Tasks:**
- Implement screenshot capture tools
- Create visual comparison utilities
- Develop visual element location tools
- Add image analysis capabilities
- Implement visual verification tools

**API Design:**
```python
@mcp.tool()
async def visual_capture(
    selector: Optional[str] = None, 
    full_page: bool = False
) -> Dict[str, Any]:
    """
    Capture a screenshot of the current page or element
    
    Args:
        selector: Optional CSS selector to capture specific element
        full_page: Whether to capture the full page
    
    Returns:
        Dictionary with screenshot data
    """
    # Implementation
```

### 2.4 WebSocket Event Subscriptions

**Implementation Tasks:**
- Create event subscription system
- Implement DOM mutation observers
- Develop network activity monitoring
- Add console log capturing
- Implement browser event forwarding

**API Design:**
```python
@app.websocket("/ws/events")
async def browser_events(websocket: WebSocket):
    """WebSocket endpoint for browser events"""
    await websocket.accept()
    
    try:
        # Register event subscriptions
        data = await websocket.receive_json()
        subscription_types = data.get("subscribe", [])
        
        # Setup event listeners
        
        # Main event loop
        while True:
            # Forward events as they occur
            pass
            
    except WebSocketDisconnect:
        # Cleanup
        pass
```

## 3. Verification Agent Integration

### 3.1 Static Analysis Integration

**Implementation Tasks:**
- Integrate Bandit for Python security analysis
- Add Semgrep for code pattern matching
- Implement ESLint for JavaScript analysis
- Create automated code review capabilities
- Develop security vulnerability scanning

**API Design:**
```python
@mcp.tool()
async def verify_code(
    code: str,
    language: str,
    rules: Optional[List[str]] = None
) -> Dict[str, Any]:
    """
    Verify code with static analysis
    
    Args:
        code: Source code to analyze
        language: Programming language (python, js, etc.)
        rules: Optional list of specific rules to check
    
    Returns:
        Dictionary with verification results
    """
    # Implementation
```

### 3.2 Unit Test Automation

**Implementation Tasks:**
- Create test generation capabilities
- Implement test runner integration
- Develop test result reporting
- Add test coverage analysis
- Implement regression test detection

**API Design:**
```python
@mcp.tool()
async def run_tests(
    test_path: str,
    test_runner: str = "pytest",
    timeout: int = 60
) -> Dict[str, Any]:
    """
    Run automated tests
    
    Args:
        test_path: Path to test files
        test_runner: Test framework to use
        timeout: Maximum test execution time
    
    Returns:
        Dictionary with test results
    """
    # Implementation
```

### 3.3 Security Checks

**Implementation Tasks:**
- Implement dependency vulnerability scanning
- Create XSS injection testing
- Develop CSRF protection verification
- Add content security policy checking
- Implement input validation testing

**API Design:**
```python
@mcp.tool()
async def security_scan(
    url: str,
    scan_type: str = "passive",
    max_depth: int = 3
) -> Dict[str, Any]:
    """
    Perform security checks on a web application
    
    Args:
        url: Target URL to scan
        scan_type: Type of scan (passive, active)
        max_depth: Maximum crawl depth
    
    Returns:
        Dictionary with security scan results
    """
    # Implementation
```

## 4. Monitoring and Metrics

### 4.1 NetData Integration

**Implementation Tasks:**
- Configure NetData for real-time metrics
- Implement custom metrics collectors
- Create dashboard for browser metrics
- Add resource usage monitoring
- Develop performance metrics visualization

**Implementation Details:**
- Install NetData in Docker environment
- Configure appropriate metrics collection
- Set up appropriate retention policies
- Create custom dashboards for browser metrics
- Implement alerting for resource thresholds

### 4.2 Loki + Grafana Setup

**Implementation Tasks:**
- Configure Loki log aggregation
- Set up Grafana dashboards
- Implement log parsing for browser events
- Create alert rules for errors
- Develop log visualization dashboards

**Implementation Details:**
- Add Loki and Grafana to Docker Compose setup
- Configure log forwarding from FastAPI and browser
- Create dashboards for error rates and patterns
- Implement alerting for critical errors
- Set up appropriate retention policies

### 4.3 cAdvisor Integration

**Implementation Tasks:**
- Configure cAdvisor for container insights
- Create container performance dashboards
- Implement resource usage monitoring
- Add container health checks
- Develop export mechanisms for metrics

**Implementation Details:**
- Add cAdvisor to Docker Compose setup
- Configure appropriate metrics collection
- Create dashboards for container performance
- Set up alerting for resource exhaustion
- Implement metrics export for historical analysis

## 5. Developer Experience

### 5.1 API Documentation

**Implementation Tasks:**
- Generate OpenAPI documentation
- Create usage examples for all endpoints
- Implement interactive API explorer
- Add error code documentation
- Develop authentication guides

**Implementation Details:**
- Use FastAPI's built-in OpenAPI generation
- Enhance docstrings for better documentation
- Create Swagger UI customization
- Add detailed examples for complex operations
- Implement playground for API testing

### 5.2 CLI Tool

**Implementation Tasks:**
- Create command-line interface for common operations
- Implement browser session management
- Develop test automation commands
- Add screenshot and visual testing capabilities
- Create reporting and export features

**Implementation Details:**
- Use Click or Typer for CLI framework
- Implement subcommands for different operation types
- Create progress indicators for long-running operations
- Add proper error handling and user feedback
- Implement configuration file support

### 5.3 Example Scripts

**Implementation Tasks:**
- Create example scripts for common use cases
- Implement tutorial notebooks
- Develop integration examples
- Add automation recipe collection
- Create debugging examples

**Implementation Details:**
- Organize examples by use case
- Provide well-documented code with comments
- Create step-by-step tutorials
- Implement real-world scenarios
- Add troubleshooting guides

## 6. Enhanced Security

### 6.1 Rate Limiting

**Implementation Tasks:**
- Implement API rate limiting
- Create rate limit configuration
- Develop rate limit bypass for authenticated users
- Add rate limit headers
- Implement rate limit logging

**Implementation Details:**
- Use FastAPI's middleware capabilities
- Create configurable rate limits per endpoint
- Implement token bucket algorithm
- Add appropriate headers for limit information
- Create monitoring for rate limit events

### 6.2 More Granular AppArmor Profiles

**Implementation Tasks:**
- Create specific AppArmor profiles for different components
- Implement resource access controls
- Develop network access restrictions
- Add file system isolation
- Create process execution controls

**Implementation Details:**
- Create separate profiles for browser and API server
- Implement least privilege principle
- Add specific resource access controls
- Test profiles for security and functionality
- Document profile configuration and management

### 6.3 Network Isolation

**Implementation Tasks:**
- Implement Docker network isolation
- Create network access controls
- Develop host protection mechanisms
- Add traffic monitoring
- Implement network security policies

**Implementation Details:**
- Configure Docker network isolation
- Implement appropriate firewall rules
- Create network segregation for components
- Add logging for network access attempts
- Document network security configuration
</file>

<file path="memory-bank/product-context.md">
# Product Context for MCP Browser

## Problem Statement

AI coding agents need to test frontend applications and verify their outputs in actual browsers to detect visual rendering issues, DOM inconsistencies, and other frontend-specific problems. Current solutions have significant limitations:

1. **Limited Rendering Fidelity**: Text-based APIs don't accurately represent visual layouts
2. **High Resource Usage**: Full browsers require excessive memory and CPU
3. **Security Concerns**: Browser automation can pose security risks
4. **Complex Setup**: Integration with AI requires specialized configuration
5. **Inconsistent Testing**: Results vary across environments

## Solution: MCP Browser

MCP Browser is a secure, resource-efficient browser automation solution specifically designed for AI coding agents. It enables AI to:

1. **Directly interact with web applications**
2. **Capture screenshots and analyze visual outputs**
3. **Inspect DOM structures and CSS properties**
4. **Detect and report frontend issues**
5. **Verify rendering across different viewports**

All while maintaining security, performance, and ease of deployment.

## Target Users

### Primary: AI Coding Agents
- L3 coding agents using the MCP protocol
- AI systems that need to verify front-end implementations

### Secondary: DevOps Teams
- Engineers deploying and maintaining the MCP Browser infrastructure
- System administrators configuring security policies

### Tertiary: Developers
- Engineers developing applications that will be tested by AI agents
- QA/testing professionals working alongside AI capabilities

## User Experience Goals

1. **For AI Agents**: 
   - Seamless browser control through MCP protocol
   - Rich feedback on rendering outcomes
   - Stable API interface for consistent interaction

2. **For DevOps Teams**:
   - One-command deployment
   - Simple configuration management
   - Comprehensive monitoring and logging
   - Minimal ongoing maintenance

3. **For Developers**:
   - Accurate representations of rendering issues
   - Detailed reports of frontend problems
   - Screenshots and evidence for debugging

## Business Value

1. **Enhanced AI Capabilities**: Enables AI to detect and fix frontend issues that would be invisible to code-only analysis
2. **Reduced Resource Costs**: 90% lower RAM usage compared to full browsers
3. **Engineering Efficiency**: Catches visual bugs earlier in the development cycle
4. **Consistency**: Ensures applications work correctly across environments
5. **Security**: Properly isolated environment for testing untrusted code

## Success Metrics

1. **Technical Performance**:
   - Browser startup time under 3 seconds
   - Memory usage below 300MB per instance
   - 99.9% uptime for the service

2. **User Success**:
   - AI agents can successfully identify 95% of frontend visual issues
   - Setup time under 10 minutes for new environments
   - Zero security breaches or container escapes

3. **Business Outcomes**:
   - Reduction in frontend issues missed by automatic testing
   - Faster debugging cycles for visual problems
   - Lower infrastructure costs for browser testing
</file>

<file path="memory-bank/progress.md">
# Progress - MCP Browser Project

## What Works

- **Screenshot Capture API**: Successfully implemented the `/api/screenshots/capture` endpoint that captures screenshots of web pages with configurable options for viewport size, image format, and quality.

- **DOM Extraction API**: Successfully implemented the `/api/dom/extract` endpoint that provides detailed DOM structure analysis with support for CSS selector targeting, style computation, and attribute extraction.

- **CSS Analysis API**: Successfully implemented the `/api/css/analyze` endpoint that extracts and analyzes CSS properties of selected elements with optional accessibility checks.

- **Accessibility Testing API**: Successfully implemented the `/api/accessibility/test` endpoint that analyzes web pages for accessibility issues following various standards like WCAG and Section 508.

- **Responsive Design Testing API**: Successfully implemented the `/api/responsive/test` endpoint that analyzes web pages across different viewport sizes to identify responsive design issues and compare element behavior.

- **MCP Protocol Extensions**: Successfully implemented the API endpoints for browser interaction including browser navigation (navigate, back, forward, refresh), DOM manipulation (click, type, select, check visibility, wait for selectors), and visual analysis (screenshot, extract text, evaluate JavaScript).

- **Testing Framework**: Created a basic testing framework with script to verify API functionality.

- **Docker Containerization**: The project successfully runs in a Docker container with appropriate security profiles.

- **Xvfb Integration**: Virtual X server is configured and functioning correctly for headless browser operation.

- **Playwright Integration**: Playwright browser automation is correctly set up and can control browser instances.

- **FastAPI Server**: Basic server is operational with API endpoints and WebSocket support.

- **Environment Configuration**: Environment variable handling is implemented with .env file support.

- **Build Scripts**: Basic build and run scripts are operational.

- **Security Profiles**: Initial AppArmor profiles are in place for container security.

- **Documentation**: Core documentation structure is established with Memory Bank approach.

## What's Left to Build

- **Additional Frontend Analysis Features**:
  - ~~Accessibility testing API~~ ✅ COMPLETED
  - ~~Responsive design testing API~~ ✅ COMPLETED

- **MCP Protocol Extensions**:
  - ~~Browser-specific MCP tools~~ ✅ COMPLETED
  - ~~DOM manipulation tools~~ ✅ COMPLETED
  - ~~Visual analysis tools~~ ✅ COMPLETED
  - ~~WebSocket event subscriptions~~ ✅ COMPLETED

- **Verification Agent**:
  - Static analysis integration
  - Unit test automation
  - Security checks implementation

- **Monitoring Tools**:
  - NetData integration
  - Loki + Grafana setup
  - cAdvisor integration

- **Developer Experience**:
  - API documentation
  - CLI tool
  - Example scripts

- **Enhanced Security**:
  - Rate limiting
  - Granular AppArmor profiles
  - Network isolation

## Current Status

**Version:** 0.4.0

The MCP Browser now supports all core protocol extensions, WebSocket event subscriptions, and has been successfully installed on a Mac Mini. The event subscription system allows clients to subscribe to various browser events (PAGE, DOM, CONSOLE, NETWORK) and receive real-time notifications when these events occur.

Key components implemented:
- HTTP API for browser control and interaction
- WebSocket endpoint for real-time browser events 
- Event subscription management endpoints
- Event filtering by URL pattern and page ID
- Comprehensive documentation of the WebSocket events feature
- Robust installation with XQuartz display server integration

## Installation Status

We have successfully addressed installation issues with XQuartz (X11) display server:
- Identified issues with XQuartz app launching on Mac Mini
- Created more robust approach to starting X11 server
- Implemented direct binary execution as a fallback
- Successfully completed installation and testing

However, we now have several redundant installation scripts that need to be consolidated:
- `install_one_line.sh`: One-line installation launcher
- `install_mcp_browser.sh`: Main installer script
- `install_helper.sh`: Helper script to fix line endings and XQuartz issues
- `simple_install.sh`: Simplified installer that skips XQuartz setup

Our cleanup plan includes:
1. Consolidate into one robust main installer script
2. Update the one-line launcher with better error handling
3. Remove redundant scripts
4. Update documentation to reflect changes

## What's Left to Build

- Script cleanup and consolidation
- Browser context management (multiple browser instances)
- Additional DOM manipulation commands
- Network interception and modification
- Cookie and storage management
- Performance metrics collection
- Integration with external tools and services

## Known Issues

- Multiple redundant installation scripts causing confusion
- WebSocket connection might drop if the browser is heavily loaded
- Some edge cases in event filtering need to be handled
- Better error reporting for failed subscriptions
- Performance optimization for high-volume event broadcasting

## Next Development Priorities

1. Clean up and consolidate installation scripts
2. Add browser context management for multi-session support
3. Implement additional DOM manipulation commands
4. Add network interception capabilities
5. Add comprehensive error handling throughout the application
6. Create a client library in Python for easier integration

## Progress Status

- [x] Project structure set up
- [x] Basic server functionality with FastAPI
- [x] Playwright integration for browser control
- [x] WebSocket interface for real-time communication
- [x] Screenshot capture API endpoint
- [x] DOM extraction API endpoint
- [x] CSS analysis API endpoint
- [x] Accessibility testing API endpoint
- [x] Responsive design testing API endpoint
- [x] MCP protocol extensions for browser interaction

## Current Focus

The current focus is on implementing and testing the core browser analysis APIs:

1. Screenshot capture - ✅ COMPLETED
2. DOM extraction - ✅ COMPLETED
3. CSS analysis - ✅ COMPLETED
4. Accessibility testing - ✅ COMPLETED
5. Responsive design testing - ✅ COMPLETED
6. MCP protocol extensions - ✅ COMPLETED

Now shifting focus to:
1. ~~WebSocket event subscriptions~~ ✅ COMPLETED
2. Resource management improvements
3. Enhanced security features

## Known Issues

| Issue | Description | Severity | Status |
|-------|-------------|----------|--------|
| Browser Resource Management | Need proper cleanup of browser resources after API calls | Medium | In Progress |
| Error Handling Consistency | Need standardized error handling across all API endpoints | Medium | To Address |
| MCPClient Implementation | The current MCPClient implementation needs refinement for stability | Medium | To Address |
| Xvfb on macOS | Xvfb configuration causes issues on macOS development environments | Low | Investigating |
| WebSocket Connections | Unexpected termination of WebSocket connections under high load | Medium | To Address |
| Resource Constraints | Current container resource limits may not be optimal | Medium | Need Testing |
- ~~DOM extraction endpoint failing with Playwright API errors~~ - FIXED
- ~~CSS analysis endpoint failing with Playwright API errors~~ - FIXED
- ~~Output files organization~~ - FIXED: All output files now stored in dedicated folders under `/output`
- Docker image build failing due to issues with Playwright base image

## Next Major Milestones

- **April 2024**: Complete frontend analysis features (screenshot, DOM, CSS analysis) ✅ COMPLETED
- **April 2024**: Complete MCP protocol integration ✅ COMPLETED
- **May 2024**: Implement WebSocket event subscriptions ✅ COMPLETED 
- **May 2024**: Implement verification agent functionality
- **May 2024**: Implement monitoring and metrics collection
- **June 2024**: Enhance developer experience with documentation and CLI tools
- **June 2024**: Production readiness with comprehensive security and testing

## Working Features

- Browser control via HTTP API
- HTTP API endpoints for all core browser actions
- Basic navigation commands (go, back, forward, refresh)
- DOM interaction (click, check visibility, wait for element)
- Data extraction (extract text, screenshot)
- JavaScript execution in the browser context
- MCP Protocol Extensions
- WebSocket event subscriptions for real-time browser event monitoring:
  - Subscription management (subscribe, unsubscribe, list)
  - Event filtering by type and URL pattern
  - Real-time event delivery
  - Graceful error handling for missing dependencies
- Test utilities for both API and WebSocket features

## Current Status

**Version:** 0.4.0

The MCP Browser now supports all core protocol extensions and WebSocket event subscriptions. The event subscription system allows clients to subscribe to various browser events (PAGE, DOM, CONSOLE, NETWORK) and receive real-time notifications when these events occur.

Key components implemented:
- HTTP API for browser control and interaction
- WebSocket endpoint for real-time browser events 
- Event subscription management endpoints
- Event filtering by URL pattern and page ID
- Comprehensive documentation of the WebSocket events feature

## What's Left to Build

- Browser context management (multiple browser instances)
- Additional DOM manipulation commands
- Network interception and modification
- Cookie and storage management
- Performance metrics collection
- Integration with external tools and services

## Known Issues

- WebSocket connection might drop if the browser is heavily loaded
- Some edge cases in event filtering need to be handled
- Better error reporting for failed subscriptions
- Performance optimization for high-volume event broadcasting

## Next Development Priorities

1. Add browser context management for multi-session support
2. Implement additional DOM manipulation commands
3. Add network interception capabilities
4. Add comprehensive error handling throughout the application
5. Create a client library in Python for easier integration
</file>

<file path="memory-bank/project-brief.md">
# MCP Browser - Project Brief

## Overview
MCP Browser is an enterprise-grade browser automation solution designed to work as a smart browser for L3 coding agents. It enables AI agents to test frontend applications in real browser environments, evaluate outputs, and identify frontend-related issues.

## Core Requirements

1. **Browser Automation Platform**
   - Headless browser execution with Playwright
   - Real browser rendering metrics and analysis
   - Virtual display server (Xvfb) for headless operation

2. **Security by Default**
   - AppArmor profiles for container security
   - Non-root execution of browser processes
   - Environment-based credential management
   - Resource limiting to prevent exhaustion
   - Isolated display server with Xvfb

3. **Deployment & Operations**
   - One-command deployment (similar to Nomad)
   - Docker containerization for consistent environments
   - Resource pooling and cost controls
   - Monitoring and metrics collection

4. **Verification & Testing**
   - Static code analysis (Bandit/Semgrep)
   - Automated testing pipeline
   - Security validation checks
   - Frontend rendering verification

5. **Agent Integration**
   - MCP (Model Control Protocol) interface for AI agents
   - Websocket communication for real-time updates
   - API for programmatic browser control
   - Screenshot and DOM analysis capabilities

## Technical Architecture

```
graph TD
    A[Claude Desktop] --> B[SSH Tunnel]
    B --> C[Older Mac/Linux PC]
    C --> D[Playwright in Docker]
    D --> E[Headless Chromium]
    D --> F[Resource Monitor]
    C --> G[MCP Server]
    G --> H[Security Sandbox]
```

## Success Criteria

1. Deploy browser automation with a single command
2. Run browser tests in isolated, secure containers
3. Provide accurate rendering analysis
4. Operate efficiently on modest hardware (90% less RAM than full browsers)
5. Maintain comprehensive security controls
6. Enable AI agents to effectively identify frontend issues

## Out of Scope

1. Full browser UI for human interaction
2. Plugin or extension management
3. Multi-user session management
4. Complex browser fingerprinting or anti-detection features
</file>

<file path="memory-bank/system-patterns.md">
# System Architecture & Patterns for MCP Browser

## System Architecture

The MCP Browser is built as a FastAPI application that acts as a bridge between client applications and a headless browser powered by Playwright. The architecture follows a modular design with several key components:

1. **HTTP API Layer**: REST endpoints for browser control and data extraction
2. **WebSocket Layer**: Real-time communication for events and interactive sessions
3. **Browser Control Layer**: Manages browser instances using Playwright
4. **Error Handling Layer**: Consistent error handling and reporting
5. **Data Processing Layer**: Processes and formats browser data for clients

```
┌─────────────────┐      ┌──────────────────┐
│                 │      │                  │
│  L3 AI Agent    │◄────►│  MCP Protocol    │
│  (Claude)       │      │                  │
│                 │      └────────┬─────────┘
└─────────────────┘               │
                                  ▼
┌─────────────────┐      ┌──────────────────┐
│                 │      │                  │
│  SSH Tunnel     │◄────►│  MCP Browser     │
│  (Security)     │      │  Service         │
│                 │      │                  │
└─────────────────┘      └────────┬─────────┘
                                  │
                                  ▼
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│                 │      │                  │      │                 │
│  Docker         │◄────►│  Playwright      │◄────►│  Xvfb Virtual   │
│  Container      │      │  Automation      │      │  Display        │
│                 │      │                  │      │                 │
└─────────────────┘      └────────┬─────────┘      └─────────────────┘
                                  │
                         ┌────────┴─────────┐
                         │                  │
                         │  Headless        │
                         │  Chromium        │
                         │                  │
                         └──────────────────┘
```

## Key Components

### 1. MCP Browser Service (FastAPI Application)
The central service that provides REST and WebSocket APIs for controlling the browser. 

**Responsibilities**:
- Manage browser sessions
- Process incoming MCP commands
- Return browser outputs to agents
- Log all operations
- Handle security and authentication

### 2. Playwright Automation Engine
Engine responsible for browser control and automation.

**Responsibilities**:
- Launch and manage browser instances
- Execute browser actions (navigation, clicks, etc.)
- Capture screenshots and DOM states
- Handle browser errors and timeouts

### 3. Xvfb Virtual Display
Virtual framebuffer that provides a display server for the headless browser.

**Responsibilities**:
- Provide X11 display environment for browser
- Isolate rendering from physical displays
- Enable screenshot and visual operations

### 4. Docker Container
Isolated environment for running the MCP Browser stack.

**Responsibilities**:
- Provide consistent execution environment
- Enforce security boundaries
- Manage resources and limits
- Enable easy deployment

### 5. SSH Tunnel
Secure connection for remote access to the service.

**Responsibilities**:
- Encrypt communications between agent and service
- Provide authentication layer
- Enable remote connections securely

## Design Patterns

### 1. Microservice Architecture
- Each component has a single responsibility
- Components communicate via well-defined interfaces
- Services can be deployed and scaled independently

### 2. Command Pattern
- Browser operations are represented as commands
- Commands are serialized, validated, and executed
- Results are returned in standardized formats

### 3. Observer Pattern
- WebSockets provide real-time updates on browser state
- Clients can subscribe to specific browser events
- Push notifications reduce polling and improve responsiveness

### 4. Factory Pattern
- Browser instances are created via factory methods
- Configuration parameters determine browser capabilities
- Resource management is centralized

### 5. REST API Design

The REST API follows a consistent pattern:
- Resource-oriented endpoints (e.g., `/api/browser/navigate`, `/api/browser/screenshot`)
- Query parameters for GET requests
- JSON bodies for POST requests
- Consistent response structure with success/error indicators

### 6. WebSocket Event Architecture

The WebSocket event system follows a publish-subscribe pattern:
1. **Connection Management**: 
   - Clients connect to the WebSocket endpoint
   - Connections are stored in a global connection pool
   - Disconnections clean up associated resources

2. **Subscription Management**:
   - Clients subscribe to specific event types
   - Subscriptions are stored with filters and client identifiers
   - Unsubscribing removes handlers and cleans up resources

3. **Event Broadcasting**:
   - Events are captured from browser actions
   - Events are filtered based on subscription criteria
   - Matching events are sent to subscribed clients

4. **Event Filtering**:
   - URL pattern matching using regular expressions
   - Page ID matching for specific page monitoring
   - Extensible filter mechanism for future criteria

### 7. Browser Control Pattern

The browser control layer follows a facade pattern:
- Encapsulates complex Playwright interactions
- Provides a simplified interface for common operations
- Handles browser lifecycle management
- Implements error recovery mechanisms

### 8. Error Handling Pattern

All API endpoints follow a consistent error handling approach:
- Try-except blocks with specific exception types
- Structured error responses with error codes and messages
- Detailed logging for debugging
- Graceful degradation when possible

## Data Flow

1. AI Agent sends command via MCP Protocol
2. MCP Browser Service receives and validates command
3. Command is translated to Playwright operations
4. Playwright executes operations in Headless Chromium
5. Results (screenshots, DOM, etc.) are captured
6. Results are formatted and returned to AI Agent
7. All operations are logged for monitoring

## Security Architecture

### Defense-in-Depth Strategy

1. **Network Level**:
   - SSH Tunnel encrypts all traffic
   - Firewall rules limit exposed ports
   - Rate limiting prevents abuse

2. **Application Level**:
   - JWT authentication for API access
   - Input validation for all parameters
   - Sanitization of all browser inputs

3. **Container Level**:
   - AppArmor profiles limit capabilities
   - Non-root user execution
   - Resource quotas prevent DoS

4. **Browser Level**:
   - Isolated browser context for each session
   - No persistent storage access
   - Restricted network access

## Key Technical Decisions

1. **Playwright over Puppeteer/Selenium**:
   - More reliable automation with fewer flaky tests
   - Better cross-browser support
   - Modern async/await API design
   - Better performance characteristics

2. **Headless Chromium as Primary Engine**:
   - Best compatibility with modern web applications
   - Excellent rendering performance
   - Strong developer tools API
   - Regular security updates

3. **Docker Containerization**:
   - Consistent environment across deployments
   - Security isolation
   - Simplified dependency management
   - Easy scaling and replication

4. **FastAPI Framework**:
   - High performance async capabilities
   - Automatic OpenAPI documentation
   - Type checking and validation
   - WebSocket support built-in

5. **Xvfb for Display**:
   - Lightweight virtual framebuffer
   - No GPU requirements
   - Works on headless servers
   - Long-established stability 

## API Endpoints

### Screenshot Capture API

**Endpoint:** `/api/screenshots/capture`

**Implementation Details:**
- Uses Playwright's screenshot functionality
- Supports both viewport and full-page screenshots
- Image format options: PNG (default) and JPEG with quality settings
- Configurable viewport dimensions
- Optional waiting mechanisms (load, networkidle, domcontentloaded)
- Results stored in `/output/screenshots/` with timestamp-based naming

**Request Parameters:**
```json
{
  "url": "https://example.com",
  "viewport": {"width": 1280, "height": 800},
  "fullPage": true,
  "format": "png",
  "quality": 90,
  "waitUntil": "networkidle",
  "selectors": ["#header", ".main-content"]
}
```

### DOM Extraction API

**Endpoint:** `/api/dom/extract`

**Implementation Details:**
- Implemented using Playwright's page.evaluate() function
- JavaScript execution in the browser context to extract DOM
- Supports full page or selector-targeted extraction
- Optional attribute and style inclusion
- Format options: HTML source or processed JSON
- Results stored in `/output/dom/` with timestamp-based naming

**Request Parameters:**
```json
{
  "url": "https://example.com",
  "selector": "#main-content",
  "includeAttributes": true,
  "includeStyles": true,
  "outputFormat": "json"
}
```

### CSS Analysis API

**Endpoint:** `/api/css/analyze`

**Implementation Details:**
- Uses Playwright for browser automation
- JavaScript execution to compute styles
- Optional property filtering
- Accessibility checks for color contrast
- Element positioning and visibility information
- Results stored in `/output/css/` with timestamp-based naming

**Request Parameters:**
```json
{
  "url": "https://example.com",
  "selectors": [".nav-item", "#main-content h1"],
  "properties": ["color", "font-size", "background-color"],
  "includeAccessibility": true,
  "includePositioning": true
}
```

### Accessibility Testing API

**Endpoint:** `/api/accessibility/test`

**Implementation Details:**
- Integration with axe-core for accessibility testing
- Multiple standard support (WCAG, Section 508)
- Selector-based testing capabilities
- Detailed violation reporting with HTML context
- Results stored in `/output/accessibility/` with timestamp-based naming

**Request Parameters:**
```json
{
  "url": "https://example.com",
  "standard": "wcag21aa",
  "selectors": ["#main-content", "nav"],
  "includeHtmlContext": true,
  "tags": ["color-contrast", "aria", "forms"]
}
```

### Responsive Design Testing API  

**Endpoint:** `/api/responsive/test`

**Implementation Details:**
- Multi-viewport testing infrastructure
- Element comparison across viewport sizes
- Media query analysis through JavaScript execution
- Touch target size validation for mobile viewports
- Screenshot capture at each viewport size
- Detailed metrics and responsive issue reporting
- Results stored in `/output/responsive/` with timestamp-based naming

**Request Parameters:**
```json
{
  "url": "https://example.com",
  "viewports": [
    {"name": "mobile", "width": 375, "height": 667},
    {"name": "tablet", "width": 768, "height": 1024},
    {"name": "desktop", "width": 1440, "height": 900}
  ],
  "selectors": [".nav-menu", "#hero-section", ".product-card"],
  "captureScreenshots": true,
  "analyzeMediaQueries": true,
  "checkTouchTargets": true
}
```

## Integration Patterns

### Browser Automation

The MCP Browser uses Playwright for browser automation with the following patterns:

1. **Browser Context Management**:
   - Single browser instance with multiple contexts
   - Context isolation for security and reliability
   - Custom viewport and user agent configuration

2. **Page Navigation Flow**:
   - Standard navigation with timeout and error handling
   - Wait until options (load, networkidle, domcontentloaded)
   - Navigation state verification

3. **JavaScript Execution**:
   - In-browser evaluation for DOM and CSS operations
   - Serialization of complex objects
   - Error handling for script execution

4. **Resource Management**:
   - Output organization by feature
   - Timestamp-based naming for artifacts
   - Cleanup routines for temporary files 

## Component Relationships

1. **Browser Initialization Flow**:
   - FastAPI app starts
   - Playwright browser is launched
   - Global variables are initialized
   - API endpoints are registered

2. **Page Management Flow**:
   - Browser context is created
   - Pages are created within context
   - Pages are tracked in a global registry
   - Events are attached to pages

3. **Event Flow**:
   - Browser or page events occur
   - Events are captured by event handlers
   - Events are processed and formatted
   - Events are broadcast to subscribed clients

4. **Resource Cleanup Flow**:
   - WebSocket connections close
   - Subscriptions are removed
   - Page resources are released
   - Browser context is cleaned up when no longer needed

## Data Models

1. **Request Models**:
   - NavigateRequest: URL and navigation options
   - ClickRequest: Selector and click options
   - EvaluateRequest: JavaScript expression and arguments

2. **Response Models**:
   - StandardResponse: Success indicator and result/error data
   - ScreenshotResponse: Image data and metadata
   - ElementDataResponse: Element properties and attributes

3. **Event Models**:
   - EventType: Enumeration of event categories
   - EventName: Enumeration of specific event names
   - EventSubscriptionModel: Subscription details and filters
   - BrowserEvent: Event data structure for broadcasting

## Technical Decisions

1. **FastAPI for API Framework**:
   - Asynchronous request handling
   - Built-in WebSocket support
   - Automatic OpenAPI documentation
   - Pydantic integration for request/response validation

2. **Playwright for Browser Automation**:
   - Cross-browser support
   - Modern browser capabilities
   - Powerful selector engine
   - Asynchronous API design

3. **Asynchronous Architecture**:
   - Non-blocking I/O for all operations
   - Efficient handling of multiple concurrent requests
   - Support for long-running operations
   - Scalable event broadcasting

4. **JSON for Data Exchange**:
   - Human-readable for debugging
   - Compatible with all client technologies
   - Schema validation with Pydantic
   - Native browser support for WebSocket communication
</file>

<file path="memory-bank/tech-context.md">
# Technical Context for MCP Browser

## Core Technologies

### Programming Languages & Frameworks
- **Python 3.13+**: Primary development language
- **FastAPI**: Modern, high-performance web framework for APIs
- **Playwright**: Browser automation framework from Microsoft
- **Docker**: Containerization technology for consistent environments
- **WebSockets**: For real-time communication between agents and browser

### Infrastructure
- **Docker Compose**: For local development and simple deployments
- **Xvfb**: Virtual framebuffer for headless browser rendering
- **AppArmor**: Linux security module for application isolation
- **uv**: Fast Python package manager and installer

### Browser Technologies
- **Chromium**: Primary browser engine
- **WebKit/Firefox**: Secondary browser engines (optional support)
- **X11**: X Window System for display server
- **HTTPS/SSL**: For secure communication

## Development Environment

### Prerequisites
- Python 3.13+
- Docker and Docker Compose
- uv package manager
- (Optional) Xvfb or XQuartz for local testing

### Project Structure
```
mcp-browser/
├── docker/                 # Docker-related files
│   ├── apparmor/           # AppArmor security profiles
│   └── xvfb-init.sh        # Xvfb initialization script
├── src/                    # Source code
│   ├── __init__.py         # Package initialization 
│   └── main.py             # Main application code
├── tests/                  # Test suite
├── .dockerignore           # Docker ignore patterns
├── .env.example            # Environment variable templates
├── .gitignore              # Git ignore patterns
├── Dockerfile              # Docker build definition
├── docker-compose.yml      # Docker Compose configuration
├── pyproject.toml          # Python project metadata
├── README.md               # Project documentation
├── run.sh                  # Deployment script
└── simple_test.sh          # Local testing script
```

## Technical Constraints

1. **Hardware Requirements**:
   - Designed to run on modest hardware (older Mac/Linux PCs)
   - Memory optimization for headless operation (90% less RAM than full browsers)

2. **Security Constraints**:
   - Non-root execution is mandatory
   - AppArmor profiles must be configured properly
   - Resource limits enforced at container level

3. **Network Constraints**:
   - SSH tunneling for remote access
   - Secure WebSocket communication
   - Port controls and exposure management

## Key Dependencies

- **mcp**: Model Control Protocol for agent communication
- **fastapi**: Web framework for API endpoints
- **playwright**: Browser automation library
- **uvicorn**: ASGI server for FastAPI
- **pyyaml**: YAML parsing for configuration
- **python-jose**: JWT support for authentication
- **passlib**: Password hashing for security
- **bcrypt**: Secure password hashing algorithm
- **requests**: HTTP client library

## Monitoring Tools

- **NetData**: Real-time metrics collection
- **Loki + Grafana**: Log aggregation and visualization
- **cAdvisor**: Container resource monitoring

## Deployment Strategy

1. **Local Development**: Docker Compose with volume mounts
2. **Production**: Docker containers with resource constraints
3. **Scaling Strategy**: Horizontal scaling with container orchestration

## Security Architecture

1. **Web Security**: HTTPS, Rate limiting
2. **Container Security**: AppArmor, Non-root user, Resource limits
3. **Authentication**: JWT tokens, Environment-based secrets
4. **Browser Isolation**: Xvfb sandboxing, Container isolation 

## Technologies Used

### Core Technologies

| Technology | Version | Purpose |
|------------|---------|---------|
| Python | 3.9+ | Primary programming language |
| FastAPI | 0.95.0+ | Web framework for API development |
| Uvicorn | 0.22.0+ | ASGI server for FastAPI |
| Playwright | 1.32.0+ | Browser automation for web page analysis |
| Docker | 20.10.0+ | Containerization for consistent environments |
| Xvfb | 1.20.0+ | Virtual framebuffer for headless browser |

### Frontend Analysis Dependencies

| Technology | Version | Purpose |
|------------|---------|---------|
| axe-core | 4.7.0+ | Accessibility testing and standards compliance |
| PIL (Pillow) | 9.5.0+ | Image processing for screenshots |
| BeautifulSoup | 4.12.0+ | HTML parsing and DOM operations |
| pydantic | 1.10.7+ | Data validation and settings management |
| pytest | 7.3.1+ | Test framework for API validation |

### Support Tools

| Technology | Version | Purpose |
|------------|---------|---------|
| GitHub Actions | N/A | CI/CD platform for automated testing |
| pre-commit | 3.3.1+ | Git hooks for code quality |
| black | 23.3.0+ | Code formatting |
| flake8 | 6.0.0+ | Code linting |
| mypy | 1.3.0+ | Static type checking |

## Development Environment

### Local Development Setup

1. **Prerequisites**:
   - Docker and Docker Compose
   - Python 3.9+
   - Git

2. **Environment Initialization**:
   ```bash
   # Clone repository
   git clone https://github.com/your-org/mcp-browser.git
   cd mcp-browser
   
   # Build and start Docker containers
   docker-compose up -d
   
   # Run the API server
   python -m scripts.run
   ```

3. **Testing Environment**:
   ```bash
   # Run tests
   pytest tests/
   
   # Run tests with coverage
   pytest --cov=app tests/
   ```

### Docker Environment

The Docker setup includes:

1. **Base Image**: Python 3.9-slim
2. **Browser Layer**: Playwright browsers installation
3. **Virtual Display**: Xvfb configuration
4. **Application Layer**: Application code and dependencies
5. **Output Volumes**: Mounted volumes for persistent output

The Dockerfile implements multi-stage building to minimize image size.

## API Design

### Request/Response Patterns

All API endpoints follow a consistent pattern:

1. **Request Structure**:
   - Required parameters: `url` (the target website)
   - Optional parameters: endpoint-specific configuration
   - Validation: Pydantic models for type safety

2. **Response Structure**:
   - Status information
   - Execution metadata (timing, browser info)
   - Result data in JSON format
   - File references for generated artifacts

3. **Error Handling**:
   - HTTP status codes for error categories
   - Detailed error messages in response body
   - Logging for debugging purposes

### API Data Flow

```
Request → Validation → Browser Setup → Page Navigation → Analysis → Result Processing → Response
```

### Authentication and Security

Current implementation uses:

1. API keys for basic authentication
2. Rate limiting by client IP
3. Input validation for all parameters
4. Timeout controls for browser operations
5. Resource limits in Docker container

## Testing Framework

The testing framework includes:

1. **Unit Tests**: Testing individual components and utilities
2. **Integration Tests**: Testing API endpoints with mock server
3. **End-to-End Tests**: Testing complete workflows with real websites
4. **Performance Tests**: Testing response times and resource usage

Test data includes a set of reference websites with known properties. 

## Technologies Used

### Core Technologies

- **Python 3.13+**: Primary programming language
- **FastAPI**: Web framework for building APIs
- **Playwright**: Browser automation library
- **Pydantic**: Data validation and settings management
- **Uvicorn**: ASGI server implementation
- **WebSockets**: Protocol for real-time communication
- **asyncio**: Asynchronous I/O library for concurrent code

### Supporting Libraries

- **websockets**: Python library for WebSocket client/server implementation
- **uuid**: Library for generating unique identifiers
- **aiohttp**: Asynchronous HTTP client/server framework
- **json**: JSON encoding/decoding
- **httpx**: Fully asynchronous HTTP client
- **aiofiles**: Asynchronous file operations

### Development Tools

- **uv**: Fast Python package installer
- **Docker**: Containerization
- **Xvfb**: Virtual framebuffer for X11 (for headless environments)
- **pytest**: Testing framework
- **autopep8**: Code formatter

## Development Setup

The project requires:

1. Python 3.13 or higher
2. uv for dependency management
3. Playwright browsers installed

Setup commands:
```bash
uv venv .venv
source .venv/bin/activate
uv pip install -e .
python -m playwright install
```

## Technical Constraints

1. **Browser Compatibility**: The system targets Chromium-based browsers for consistent behavior.
2. **Memory Usage**: Browser automation is memory-intensive, requiring at least 2GB RAM.
3. **Event Broadcasting**: WebSocket connections for event subscriptions require consideration for scaling.
4. **Asynchronous Architecture**: All components must be designed to work in an asynchronous environment.

## Dependencies

### Core Dependencies

```
fastapi>=0.97.0
playwright>=1.40.0
uvicorn>=0.22.0
pydantic>=2.0.0
websockets>=11.0.3
```

### Test Dependencies

```
pytest>=7.0.0
httpx>=0.24.1
pytest-asyncio>=0.21.1
```

## Configuration

Key environment variables:
- `SERVER_PORT`: Web server port (default: 7665)
- `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD`: Skip browser download for headless mode
- `MCP_SECRET`: Secret key for MCP authentication

## Deployment

The application supports:
1. Local development environment
2. Docker containerized deployment
3. Production deployment with appropriate scaling

## Third-Party Integrations

The system is designed to integrate with:
1. **MCP**: For AI agent communication
2. **External services**: Via the HTTP API
3. **Client applications**: Via WebSockets and HTTP API
</file>

<file path="src/__init__.py">
"""
MCP Browser - A browser interface for MCP (Model Control Protocol)
"""
__version__ = "0.1.0"
</file>

<file path="src/browser_pool.py">
#!/usr/bin/env python3
"""
Browser Pool for MCP Browser
This module provides a pool of browser instances for efficient resource management.
"""
import os
import asyncio
import logging
from typing import Dict, List, Optional, Any, Set
import time
import uuid
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("browser-pool")
class BrowserInstance:
    """Represents a browser instance in the pool"""
    def __init__(self, instance_id: str):
        """
        Initialize a browser instance
        Args:
            instance_id: Unique identifier for this browser instance
        """
        self.id = instance_id
        self.contexts: Dict[str, Any] = {}
        self.last_used = time.time()
        self.browser = None
        self.is_closing = False
        logger.info(f"Created browser instance {self.id}")
    async def initialize(self):
        """Initialize the browser instance"""
        # In a real implementation, this would launch Playwright browser
        logger.info(f"Initializing browser instance {self.id}")
        self.browser = {"id": self.id, "status": "ready"}
        return self.browser
    async def create_context(self, context_id: str, **kwargs) -> Dict[str, Any]:
        """
        Create a new browser context
        Args:
            context_id: Unique identifier for this context
            **kwargs: Additional context options
        Returns:
            Browser context object
        """
        logger.info(f"Creating context {context_id} in browser {self.id}")
        # In a real implementation, this would create a Playwright context
        context = {
            "id": context_id,
            "browser_id": self.id,
            "created_at": time.time(),
            "options": kwargs,
            "pages": []
        }
        self.contexts[context_id] = context
        self.last_used = time.time()
        return context
    async def close_context(self, context_id: str):
        """
        Close a browser context
        Args:
            context_id: ID of the context to close
        """
        if context_id not in self.contexts:
            logger.warning(f"Context {context_id} not found in browser {self.id}")
            return
        logger.info(f"Closing context {context_id} in browser {self.id}")
        # In a real implementation, this would close the Playwright context
        del self.contexts[context_id]
        self.last_used = time.time()
    async def close(self):
        """Close the browser instance and all its contexts"""
        if self.is_closing:
            return
        self.is_closing = True
        logger.info(f"Closing browser instance {self.id}")
        # Close all contexts
        for context_id in list(self.contexts.keys()):
            await self.close_context(context_id)
        # In a real implementation, this would close the Playwright browser
        self.browser = None
        logger.info(f"Browser instance {self.id} closed")
class BrowserPool:
    """Manages a pool of browser instances"""
    def __init__(self, max_browsers: int = 10, idle_timeout: int = 300):
        """
        Initialize the browser pool
        Args:
            max_browsers: Maximum number of concurrent browser instances
            idle_timeout: Time in seconds after which idle browsers are closed
        """
        self.max_browsers = max_browsers
        self.idle_timeout = idle_timeout
        self.browsers: Dict[str, BrowserInstance] = {}
        self.cleanup_task = None
        self.lock = asyncio.Lock()
        logger.info(f"Browser pool initialized with max_browsers={max_browsers}, idle_timeout={idle_timeout}s")
    async def start(self):
        """Start the browser pool and cleanup task"""
        logger.info("Starting browser pool")
        self.cleanup_task = asyncio.create_task(self._cleanup_task())
    async def stop(self):
        """Stop the browser pool and close all browsers"""
        logger.info("Stopping browser pool")
        if self.cleanup_task:
            self.cleanup_task.cancel()
            try:
                await self.cleanup_task
            except asyncio.CancelledError:
                pass
        # Close all browsers
        async with self.lock:
            for browser_id in list(self.browsers.keys()):
                await self.close_browser(browser_id)
        logger.info("Browser pool stopped")
    async def get_browser(self) -> BrowserInstance:
        """
        Get a browser instance from the pool
        Returns:
            A browser instance
        """
        async with self.lock:
            # Check if we can create a new browser
            if len(self.browsers) >= self.max_browsers:
                # Find the least recently used browser
                browser_id = min(self.browsers.items(), key=lambda x: x[1].last_used)[0]
                logger.info(f"Reusing existing browser {browser_id}")
                browser = self.browsers[browser_id]
            else:
                # Create a new browser
                browser_id = str(uuid.uuid4())
                browser = BrowserInstance(browser_id)
                self.browsers[browser_id] = browser
                # Initialize the browser
                await browser.initialize()
            browser.last_used = time.time()
            return browser
    async def close_browser(self, browser_id: str):
        """
        Close a browser instance
        Args:
            browser_id: ID of the browser to close
        """
        if browser_id not in self.browsers:
            logger.warning(f"Browser {browser_id} not found in pool")
            return
        browser = self.browsers[browser_id]
        await browser.close()
        del self.browsers[browser_id]
        logger.info(f"Removed browser {browser_id} from pool, {len(self.browsers)} browsers remaining")
    async def _cleanup_task(self):
        """Background task to clean up idle browsers"""
        try:
            while True:
                await asyncio.sleep(60)  # Check every minute
                now = time.time()
                to_close = []
                async with self.lock:
                    for browser_id, browser in self.browsers.items():
                        if now - browser.last_used > self.idle_timeout:
                            to_close.append(browser_id)
                if to_close:
                    logger.info(f"Closing {len(to_close)} idle browsers")
                    for browser_id in to_close:
                        await self.close_browser(browser_id)
        except asyncio.CancelledError:
            logger.info("Cleanup task cancelled")
            raise
        except Exception as e:
            logger.error(f"Error in cleanup task: {str(e)}", exc_info=True)
# Global instance
browser_pool = None
async def initialize_browser_pool(max_browsers: int = 10, idle_timeout: int = 300):
    """
    Initialize the global browser pool
    Args:
        max_browsers: Maximum number of concurrent browser instances
        idle_timeout: Time in seconds after which idle browsers are closed
    """
    global browser_pool
    if browser_pool is None:
        browser_pool = BrowserPool(max_browsers, idle_timeout)
        await browser_pool.start()
    return browser_pool
async def close_browser_pool():
    """Close the global browser pool"""
    global browser_pool
    if browser_pool is not None:
        await browser_pool.stop()
        browser_pool = None
</file>

<file path="src/error_handler.py">
#!/usr/bin/env python3
"""
Error Handler for MCP Browser
This module provides standardized error handling for the MCP Browser application.
"""
import enum
import logging
import traceback
import asyncio
import functools
from typing import Dict, List, Optional, Any, Callable, TypeVar, Union
from pydantic import BaseModel
from fastapi import HTTPException, status
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("error-handler")
class ErrorCode(enum.Enum):
    """Standard error codes for the application"""
    # Authentication errors (1000-1099)
    AUTH_INVALID_CREDENTIALS = 1000
    AUTH_TOKEN_EXPIRED = 1001
    AUTH_INVALID_TOKEN = 1002
    AUTH_INSUFFICIENT_PERMISSIONS = 1003
    AUTH_USER_DISABLED = 1004
    # Browser operation errors (2000-2099)
    BROWSER_NAVIGATION_FAILED = 2000
    BROWSER_TIMEOUT = 2001
    BROWSER_ELEMENT_NOT_FOUND = 2002
    BROWSER_EXECUTION_FAILED = 2003
    BROWSER_PAGE_CRASHED = 2004
    # Resource management errors (3000-3099)
    RESOURCE_NOT_FOUND = 3000
    RESOURCE_POOL_EXHAUSTED = 3001
    RESOURCE_ALREADY_EXISTS = 3002
    RESOURCE_LIMIT_EXCEEDED = 3003
    # Input validation errors (4000-4099)
    VALIDATION_ERROR = 4000
    INVALID_URL = 4001
    INVALID_SELECTOR = 4002
    INVALID_PARAMETER = 4003
    # System errors (5000-5099)
    INTERNAL_ERROR = 5000
    DEPENDENCY_ERROR = 5001
    NETWORK_ERROR = 5002
    DATABASE_ERROR = 5003
class ErrorDetail(BaseModel):
    """Detailed error information"""
    field: Optional[str] = None
    message: str
    code: Optional[str] = None
class ErrorResponse(BaseModel):
    """Standardized error response"""
    error_code: int
    message: str
    status_code: int
    details: Optional[List[ErrorDetail]] = None
# Map error codes to HTTP status codes
ERROR_STATUS_CODES = {
    # Authentication errors
    ErrorCode.AUTH_INVALID_CREDENTIALS: status.HTTP_401_UNAUTHORIZED,
    ErrorCode.AUTH_TOKEN_EXPIRED: status.HTTP_401_UNAUTHORIZED,
    ErrorCode.AUTH_INVALID_TOKEN: status.HTTP_401_UNAUTHORIZED,
    ErrorCode.AUTH_INSUFFICIENT_PERMISSIONS: status.HTTP_403_FORBIDDEN,
    ErrorCode.AUTH_USER_DISABLED: status.HTTP_403_FORBIDDEN,
    # Browser operation errors
    ErrorCode.BROWSER_NAVIGATION_FAILED: status.HTTP_400_BAD_REQUEST,
    ErrorCode.BROWSER_TIMEOUT: status.HTTP_408_REQUEST_TIMEOUT,
    ErrorCode.BROWSER_ELEMENT_NOT_FOUND: status.HTTP_404_NOT_FOUND,
    ErrorCode.BROWSER_EXECUTION_FAILED: status.HTTP_500_INTERNAL_SERVER_ERROR,
    ErrorCode.BROWSER_PAGE_CRASHED: status.HTTP_500_INTERNAL_SERVER_ERROR,
    # Resource management errors
    ErrorCode.RESOURCE_NOT_FOUND: status.HTTP_404_NOT_FOUND,
    ErrorCode.RESOURCE_POOL_EXHAUSTED: status.HTTP_503_SERVICE_UNAVAILABLE,
    ErrorCode.RESOURCE_ALREADY_EXISTS: status.HTTP_409_CONFLICT,
    ErrorCode.RESOURCE_LIMIT_EXCEEDED: status.HTTP_429_TOO_MANY_REQUESTS,
    # Input validation errors
    ErrorCode.VALIDATION_ERROR: status.HTTP_400_BAD_REQUEST,
    ErrorCode.INVALID_URL: status.HTTP_400_BAD_REQUEST,
    ErrorCode.INVALID_SELECTOR: status.HTTP_400_BAD_REQUEST,
    ErrorCode.INVALID_PARAMETER: status.HTTP_400_BAD_REQUEST,
    # System errors
    ErrorCode.INTERNAL_ERROR: status.HTTP_500_INTERNAL_SERVER_ERROR,
    ErrorCode.DEPENDENCY_ERROR: status.HTTP_502_BAD_GATEWAY,
    ErrorCode.NETWORK_ERROR: status.HTTP_503_SERVICE_UNAVAILABLE,
    ErrorCode.DATABASE_ERROR: status.HTTP_500_INTERNAL_SERVER_ERROR
}
class MCPBrowserException(Exception):
    """Custom exception for MCP Browser application"""
    def __init__(
        self, 
        error_code: ErrorCode,
        message: str = None,
        status_code: int = None,
        details: List[ErrorDetail] = None,
        original_exception: Exception = None
    ):
        """
        Initialize the exception
        Args:
            error_code: Error code from ErrorCode enum
            message: Error message
            status_code: HTTP status code (overrides the default for the error code)
            details: List of error details
            original_exception: The original exception that caused this error
        """
        self.error_code = error_code
        self.message = message or error_code.name
        self.status_code = status_code or ERROR_STATUS_CODES.get(
            error_code, status.HTTP_500_INTERNAL_SERVER_ERROR
        )
        self.details = details or []
        self.original_exception = original_exception
        # Log the error with traceback if there was an original exception
        if original_exception:
            logger.error(
                f"Error {error_code.name}: {message}",
                exc_info=original_exception
            )
        else:
            logger.error(f"Error {error_code.name}: {message}")
        super().__init__(self.message)
    def to_response(self) -> ErrorResponse:
        """
        Convert the exception to a standardized error response
        Returns:
            ErrorResponse object
        """
        return ErrorResponse(
            error_code=self.error_code.value,
            message=self.message,
            status_code=self.status_code,
            details=self.details
        )
    def to_http_exception(self) -> HTTPException:
        """
        Convert the exception to an HTTPException
        Returns:
            HTTPException object
        """
        response = self.to_response()
        return HTTPException(
            status_code=self.status_code,
            detail=response.dict()
        )
class RetryConfig:
    """Configuration for retry mechanism"""
    def __init__(
        self,
        max_retries: int = 3,
        initial_delay: float = 1.0,
        max_delay: float = 30.0,
        backoff_factor: float = 2.0,
        retryable_errors: List[ErrorCode] = None
    ):
        """
        Initialize retry configuration
        Args:
            max_retries: Maximum number of retry attempts
            initial_delay: Initial delay in seconds before the first retry
            max_delay: Maximum delay in seconds between retries
            backoff_factor: Multiplier for the delay between retries
            retryable_errors: List of error codes that should be retried
        """
        self.max_retries = max_retries
        self.initial_delay = initial_delay
        self.max_delay = max_delay
        self.backoff_factor = backoff_factor
        self.retryable_errors = retryable_errors or [
            ErrorCode.BROWSER_TIMEOUT,
            ErrorCode.NETWORK_ERROR,
            ErrorCode.RESOURCE_POOL_EXHAUSTED,
            ErrorCode.DEPENDENCY_ERROR
        ]
# Default retry configuration
DEFAULT_RETRY_CONFIG = RetryConfig()
# Type variable for return type
T = TypeVar('T')
async def with_retry(
    func: Callable[..., Any],
    *args,
    retry_config: RetryConfig = DEFAULT_RETRY_CONFIG,
    **kwargs
) -> Any:
    """
    Execute a function with retry logic
    Args:
        func: Function to execute
        *args: Positional arguments for the function
        retry_config: Retry configuration
        **kwargs: Keyword arguments for the function
    Returns:
        Result of the function
    Raises:
        MCPBrowserException: If all retries fail
    """
    retries = 0
    last_exception = None
    while retries <= retry_config.max_retries:
        try:
            return await func(*args, **kwargs)
        except MCPBrowserException as e:
            # Only retry for specified error codes
            if e.error_code not in retry_config.retryable_errors:
                raise
            last_exception = e
            retries += 1
            if retries > retry_config.max_retries:
                break
            # Calculate delay with exponential backoff
            delay = min(
                retry_config.initial_delay * (retry_config.backoff_factor ** (retries - 1)),
                retry_config.max_delay
            )
            logger.warning(
                f"Retry {retries}/{retry_config.max_retries} for error {e.error_code.name} "
                f"after {delay:.2f}s delay"
            )
            await asyncio.sleep(delay)
        except Exception as e:
            # Wrap unexpected exceptions
            error = MCPBrowserException(
                error_code=ErrorCode.INTERNAL_ERROR,
                message=f"Unexpected error: {str(e)}",
                original_exception=e
            )
            last_exception = error
            retries += 1
            if retries > retry_config.max_retries:
                break
            # Calculate delay with exponential backoff
            delay = min(
                retry_config.initial_delay * (retry_config.backoff_factor ** (retries - 1)),
                retry_config.max_delay
            )
            logger.warning(
                f"Retry {retries}/{retry_config.max_retries} for unexpected error "
                f"after {delay:.2f}s delay"
            )
            await asyncio.sleep(delay)
    # If we get here, all retries failed
    if last_exception:
        # Update the message to indicate retry failure
        if isinstance(last_exception, MCPBrowserException):
            last_exception.message = f"Failed after {retries} retries: {last_exception.message}"
        raise last_exception
    # This should not happen but just in case
    raise MCPBrowserException(
        error_code=ErrorCode.INTERNAL_ERROR,
        message=f"Failed after {retries} retries with no specific error"
    )
def handle_exceptions(func):
    """
    Decorator to handle exceptions in async functions
    Args:
        func: Async function to wrap
    Returns:
        Wrapped function
    """
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except MCPBrowserException as e:
            # Convert to HTTP exception
            raise e.to_http_exception()
        except Exception as e:
            # Wrap unexpected exceptions
            error = MCPBrowserException(
                error_code=ErrorCode.INTERNAL_ERROR,
                message=f"Unexpected error: {str(e)}",
                original_exception=e
            )
            raise error.to_http_exception()
    return wrapper
</file>

<file path="src/integrate_components.py">
#!/usr/bin/env python3
"""
Integration script for MCP Browser components
This script updates the main.py file to use the BrowserPool, error handling,
and authentication components we've implemented.
"""
import os
import sys
import asyncio
import logging
from typing import Dict, List, Optional, Any
from contextlib import asynccontextmanager
from fastapi import FastAPI
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("mcp-browser-integration")
async def main():
    """Main integration function"""
    logger.info("Starting MCP Browser component integration")
    # Get paths
    script_dir = os.path.dirname(os.path.realpath(__file__))
    main_file = os.path.join(script_dir, "main.py")
    integration_file = os.path.join(script_dir, "integration.py")
    browser_pool_file = os.path.join(script_dir, "browser_pool.py")
    error_handler_file = os.path.join(script_dir, "error_handler.py")
    # Verify all files exist
    for file in [main_file, integration_file, browser_pool_file, error_handler_file]:
        if not os.path.exists(file):
            logger.error(f"Required file not found: {file}")
            return 1
    # Install component imports in main.py
    logger.info("Installing component imports in main.py")
    await install_imports(main_file)
    # Replace existing browser initialization with BrowserPool
    logger.info("Replacing browser initialization with BrowserPool")
    await replace_browser_init(main_file)
    # Apply error handling to critical endpoints
    logger.info("Applying error handling to critical endpoints")
    await apply_error_handling(main_file)
    # Update auth system to use new components
    logger.info("Updating auth system")
    await update_auth_system(main_file)
    # Add token refresh endpoint
    logger.info("Adding token refresh endpoint")
    await add_token_refresh(main_file)
    # Add rate limiting
    logger.info("Adding rate limiting")
    await add_rate_limiting(main_file)
    logger.info("MCP Browser component integration completed successfully")
    return 0
async def install_imports(main_file: str):
    """
    Install required imports in the main application file
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Prepare the new imports to add
    new_imports = """
# Component integration imports
from integration import browser_manager, auth_manager, configure_app, handle_exceptions, with_retry, DEFAULT_RETRY_CONFIG
from error_handler import MCPBrowserException, ErrorCode, RetryConfig
"""
    # Add imports after the last import statement
    import_section_end = content.rfind("import") + content[content.rfind("import"):].find('\n') + 1
    updated_content = content[:import_section_end] + new_imports + content[import_section_end:]
    with open(main_file, 'w') as f:
        f.write(updated_content)
    logger.info("Component imports added to main.py")
async def replace_browser_init(main_file: str):
    """
    Replace existing browser initialization with BrowserPool integration and lifespan events
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Check if file already contains lifespan context manager
    if "asynccontextmanager" in content and "@asynccontextmanager" in content:
        logger.info("File already contains lifespan context manager")
        return
    # Add imports for asynccontextmanager if needed
    if "from contextlib import asynccontextmanager" not in content:
        if "from typing import" in content:
            content = content.replace(
                "from typing import", 
                "from typing import AsyncGenerator, "
            )
        else:
            # Add imports near the top after other imports
            import_end = content.find("# Configure logging")
            if import_end == -1:
                import_end = content.find("import ")
                import_end = content.find("\n", import_end) + 1
            content = (
                content[:import_end] + 
                "from contextlib import asynccontextmanager\n" + 
                "from typing import AsyncGenerator\n" + 
                content[import_end:]
            )
    # Look for app initialization
    app_init_start = content.find("app = FastAPI(")
    if app_init_start == -1:
        logger.error("Could not find FastAPI app initialization")
        return
    app_init_end = content.find(")", app_init_start)
    if app_init_end == -1:
        logger.error("Could not determine end of FastAPI app initialization")
        return
    # Create lifespan function
    lifespan_code = """
# Define lifespan context manager
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    \"\"\"Lifespan context manager for startup and shutdown events\"\"\"
    global app_state
    app_state = {}
    # Configure the app with integration components
    configure_app(app)
    # Initialize MCP client for tool registration
    if os.environ.get("MCP_SERVER_URL") and os.environ.get("MCP_API_KEY"):
        app_state["mcp_client"] = MCPClient(
            model_name=os.environ.get("MCP_MODEL_NAME", "mcp-browser"),
            server_url=os.environ.get("MCP_SERVER_URL"),
            api_key=os.environ.get("MCP_API_KEY")
        )
        try:
            await app_state["mcp_client"].register_tools()
            logger.info("MCP tools registered successfully")
        except Exception as e:
            logger.error(f"Failed to register MCP tools: {str(e)}")
    else:
        logger.warning("MCP_SERVER_URL or MCP_API_KEY not set, skipping MCP tool registration")
    # Initialize event subscriptions
    app_state["subscriptions"] = {}
    logger.info("MCP Browser server started")
    yield  # Run the application
    # Cleanup on shutdown
    # Close MCP client
    if app_state.get("mcp_client"):
        await app_state["mcp_client"].close()
    # Clear subscriptions
    app_state["subscriptions"] = {}
    logger.info("MCP Browser server shut down")
"""
    # Find a good insertion point for the lifespan function
    # Look for # App state or some other clear marker before app initialization
    app_state_pos = content.find("# App state")
    if app_state_pos == -1:
        # Insert after imports but before app initialization
        app_state_pos = content.find("# Configure logging")
        if app_state_pos == -1:
            app_state_pos = app_init_start
        else:
            # Find the next section after logging config
            next_section = content.find("#", app_state_pos + 15)
            if next_section != -1 and next_section < app_init_start:
                app_state_pos = next_section
            else:
                app_state_pos = app_init_start
    # Insert lifespan code before app initialization
    content = content[:app_state_pos] + lifespan_code + content[app_state_pos:]
    # Update app initialization to use lifespan
    app_init_content = content[app_init_start:app_init_end+1]
    if "lifespan=lifespan" not in app_init_content:
        # Check if there's a comma at the end of the last parameter
        if app_init_content.rstrip().endswith(","):
            new_app_init = app_init_content.rstrip() + "\n    lifespan=lifespan\n)"
        else:
            new_app_init = app_init_content.rstrip()[:-1] + ",\n    lifespan=lifespan\n)"
        # Replace app initialization
        content = content[:app_init_start] + new_app_init + content[app_init_end+1:]
    # Remove old @app.on_event handlers that we've replaced with lifespan
    startup_event_pos = content.find('@app.on_event("startup")')
    if startup_event_pos != -1:
        # Find the end of the startup_event function
        function_start = content.find("async def startup_event", startup_event_pos)
        if function_start != -1:
            # Find the end of the function by looking for the next function or class
            next_func = content.find("@app", function_start + 30)
            if next_func == -1:
                next_func = content.find("def ", function_start + 30)
            if next_func == -1:
                next_func = content.find("class ", function_start + 30)
            if next_func != -1:
                # Remove the startup event handler
                content = content[:startup_event_pos] + content[next_func:]
    shutdown_event_pos = content.find('@app.on_event("shutdown")')
    if shutdown_event_pos != -1:
        # Find the end of the shutdown_event function
        function_start = content.find("async def shutdown_event", shutdown_event_pos)
        if function_start != -1:
            # Find the end of the function by looking for the next function or class
            next_func = content.find("@app", function_start + 30)
            if next_func == -1:
                next_func = content.find("def ", function_start + 30)
            if next_func == -1:
                next_func = content.find("class ", function_start + 30)
            if next_func != -1:
                # Remove the shutdown event handler
                content = content[:shutdown_event_pos] + content[next_func:]
    # Write updated content back to file
    with open(main_file, 'w') as f:
        f.write(content)
    logger.info("Updated main.py with lifespan event handlers and browser integration")
async def apply_error_handling(main_file: str):
    """
    Apply error handling to critical endpoints
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Identify critical browser endpoints to apply error handling
    endpoints = [
        "@app.post(\"/api/browser/navigate\")",
        "@app.post(\"/api/browser/back\")",
        "@app.post(\"/api/browser/forward\")",
        "@app.post(\"/api/browser/refresh\")",
        "@app.post(\"/api/browser/click\")",
        "@app.post(\"/api/browser/type\")",
        "@app.post(\"/api/browser/select\")",
        "@app.post(\"/api/browser/fill_form\")",
        "@app.post(\"/api/browser/screenshot\")",
        "@app.post(\"/api/browser/extract_text\")",
        "@app.post(\"/api/browser/check_visibility\")",
        "@app.post(\"/api/browser/wait_for_selector\")",
        "@app.post(\"/api/browser/evaluate\")",
        "@app.post(\"/api/screenshots/capture\")",
        "@app.post(\"/api/dom/extract\")",
        "@app.post(\"/api/css/analyze\")",
        "@app.post(\"/api/accessibility/test\")",
        "@app.post(\"/api/responsive/test\")"
    ]
    updated_content = content
    # Add the handle_exceptions decorator to each endpoint
    for endpoint in endpoints:
        endpoint_pos = updated_content.find(endpoint)
        if endpoint_pos == -1:
            logger.warning(f"Could not find endpoint: {endpoint}")
            continue
        # Check if handle_exceptions is already applied
        prev_lines = updated_content[max(0, endpoint_pos - 100):endpoint_pos].splitlines()
        if any("@handle_exceptions" in line for line in prev_lines[-3:]):
            logger.info(f"handle_exceptions already applied to {endpoint}")
            continue
        # Add the decorator
        updated_content = updated_content[:endpoint_pos] + "@handle_exceptions\n" + updated_content[endpoint_pos:]
    with open(main_file, 'w') as f:
        f.write(updated_content)
    logger.info("Error handling applied to critical endpoints")
async def update_auth_system(main_file: str):
    """
    Update authentication system to use the integrated auth manager
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Find existing auth function implementations that need to be updated
    functions_to_update = [
        "def create_access_token",
        "async def get_current_user",
        "async def get_current_active_user",
        "def has_permission",
        "async def get_token_from_query",
        "async def verify_websocket_token"
    ]
    updated_content = content
    # Comment out each function and replace with a reference to auth_manager
    for func in functions_to_update:
        func_pos = updated_content.find(func)
        if func_pos == -1:
            logger.warning(f"Could not find function: {func}")
            continue
        # Find function start
        function_start = updated_content.rfind("\n", 0, func_pos) + 1
        # Find function end (next function def or class def)
        next_func = updated_content.find("def ", func_pos + len(func))
        next_class = updated_content.find("class ", func_pos + len(func))
        if next_func == -1 and next_class == -1:
            function_end = len(updated_content)
        elif next_func == -1:
            function_end = next_class
        elif next_class == -1:
            function_end = next_func
        else:
            function_end = min(next_func, next_class)
        # Find the indentation before the function
        func_lines = updated_content[function_start:function_end].splitlines()
        # Comment out the entire function
        commented_function = "# Auth system now managed by auth_manager\n"
        commented_function += "# " + "\n# ".join(func_lines)
        # Replace the function with commented version
        updated_content = updated_content[:function_start] + commented_function + updated_content[function_end:]
    with open(main_file, 'w') as f:
        f.write(updated_content)
    logger.info("Auth system updated to use auth_manager")
async def add_token_refresh(main_file: str):
    """
    Add token refresh endpoint
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Find a good place to add the token refresh endpoint (after the login endpoint)
    login_endpoint = content.find("@app.post(\"/token\"")
    if login_endpoint == -1:
        logger.warning("Could not find login endpoint to add token refresh")
        return
    # Find the end of the login endpoint function
    login_function_end = content.find("@app", login_endpoint + 1)
    if login_function_end == -1:
        logger.warning("Could not determine end of login function")
        return
    # New refresh token endpoint code
    refresh_endpoint = """
@app.post("/token/refresh", response_model=Token)
@handle_exceptions
async def refresh_access_token(refresh_token: str = Body(...)):
    """
    Refresh an access token using a refresh token
    Args:
        refresh_token: Valid refresh token
    Returns:
        New access token
    Raises:
        HTTPException: If refresh token is invalid
    """
    try:
        # Verify the refresh token
        payload = await auth_manager.decode_token(refresh_token)
        # Check if it's actually a refresh token
        if not payload.get("refresh"):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Not a refresh token"
            )
        # Check username
        username = payload.get("sub")
        if not username:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token"
            )
        # Get permissions from the refresh token
        permissions = payload.get("permissions", [])
        # Create a new access token
        access_token = await auth_manager.create_access_token(
            data={"sub": username, "permissions": permissions}
        )
        return {"access_token": access_token, "token_type": "bearer"}
    except (JWTError, MCPBrowserException) as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid refresh token: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"}
        )
"""
    # Add the refresh endpoint after the login endpoint
    updated_content = content[:login_function_end] + refresh_endpoint + content[login_function_end:]
    with open(main_file, 'w') as f:
        f.write(updated_content)
    logger.info("Token refresh endpoint added")
async def add_rate_limiting(main_file: str):
    """
    Add rate limiting to sensitive endpoints
    Args:
        main_file: Path to main.py
    """
    with open(main_file, 'r') as f:
        content = f.read()
    # Add rate limiting imports and middleware
    imports_end = content.find("# Component integration imports") + content[content.find("# Component integration imports"):].find('\n') + 1
    rate_limit_imports = """
# Rate limiting
from fastapi import Depends, Request
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
"""
    updated_content = content[:imports_end] + rate_limit_imports + content[imports_end:]
    # Add limiter initialization before the app creation
    app_creation = updated_content.find("app = FastAPI(")
    if app_creation == -1:
        logger.warning("Could not find FastAPI app creation")
        return
    limiter_init = """
# Initialize rate limiter
limiter = Limiter(key_func=get_remote_address)
"""
    updated_content = updated_content[:app_creation] + limiter_init + updated_content[app_creation:]
    # Add middleware configuration after app creation
    app_created_end = updated_content.find("app = FastAPI(") + updated_content[updated_content.find("app = FastAPI("):].find(')') + 1
    middleware_config = """
# Add rate limiting middleware
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
# Add trusted host middleware
app.add_middleware(
    TrustedHostMiddleware, 
    allowed_hosts=os.environ.get("ALLOWED_HOSTS", "*").split(",")
)
"""
    updated_content = updated_content[:app_created_end] + middleware_config + updated_content[app_created_end:]
    # Add rate limiting to sensitive endpoints
    sensitive_endpoints = [
        "@app.post(\"/token\"",
        "@app.post(\"/token/refresh\"",
    ]
    for endpoint in sensitive_endpoints:
        endpoint_pos = updated_content.find(endpoint)
        if endpoint_pos == -1:
            logger.warning(f"Could not find endpoint: {endpoint}")
            continue
        # Check if rate limiting is already applied
        prev_lines = updated_content[max(0, endpoint_pos - 100):endpoint_pos].splitlines()
        if any("@limiter.limit" in line for line in prev_lines[-3:]):
            logger.info(f"Rate limiting already applied to {endpoint}")
            continue
        # Add the rate limiter
        updated_content = updated_content[:endpoint_pos] + '@limiter.limit("5/minute")\n' + updated_content[endpoint_pos:]
    with open(main_file, 'w') as f:
        f.write(updated_content)
    logger.info("Rate limiting added to sensitive endpoints")
if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        logger.info("Integration cancelled by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Integration failed: {str(e)}", exc_info=True)
        sys.exit(1)
</file>

<file path="src/integration.py">
#!/usr/bin/env python3
"""
Integration Module for MCP Browser
This module integrates BrowserPool, error handling, and authentication components.
"""
import os
import logging
import asyncio
import time
import uuid
from typing import Dict, List, Optional, Any, Set, Callable, AsyncGenerator
from datetime import datetime, timedelta
import jwt
from fastapi import FastAPI, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel
from contextlib import asynccontextmanager
# Import our components
from browser_pool import BrowserInstance, browser_pool, initialize_browser_pool, close_browser_pool
from error_handler import (
    MCPBrowserException, ErrorCode, RetryConfig, with_retry, handle_exceptions, DEFAULT_RETRY_CONFIG
)
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("integration")
# OAuth2 password bearer for token authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
# JWT configuration
JWT_SECRET_KEY = os.environ.get("JWT_SECRET_KEY", "mcp-browser-default-secret-key")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.environ.get("ACCESS_TOKEN_EXPIRE_MINUTES", 30))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.environ.get("REFRESH_TOKEN_EXPIRE_DAYS", 7))
# User models
class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    disabled: Optional[bool] = None
    permissions: List[str] = []
# Fake database for demo
fake_users_db = {
    "admin": {
        "username": "admin",
        "full_name": "Administrator",
        "email": "admin@example.com",
        "disabled": False,
        "permissions": ["browser:full", "admin"]
    },
    "user": {
        "username": "user",
        "full_name": "Regular User",
        "email": "user@example.com",
        "disabled": False,
        "permissions": ["browser:basic"]
    }
}
class BrowserManager:
    """Manager for browser resources"""
    def __init__(self):
        """Initialize the browser manager"""
        self.session_contexts = {}  # Maps session IDs to context IDs
    async def initialize(self, max_browsers: int = 10, idle_timeout: int = 300):
        """
        Initialize the browser manager
        Args:
            max_browsers: Maximum number of concurrent browser instances
            idle_timeout: Time in seconds after which idle browsers are closed
        """
        await initialize_browser_pool(max_browsers, idle_timeout)
        logger.info(f"Browser manager initialized with max_browsers={max_browsers}")
    async def shutdown(self):
        """Shutdown the browser manager"""
        await close_browser_pool()
        logger.info("Browser manager shut down")
    async def create_browser_context(
        self, 
        session_id: str, 
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a browser context for a session
        Args:
            session_id: Session identifier
            user_id: User identifier
        Returns:
            Context information
        """
        try:
            # Get a browser from the pool
            browser_instance = await browser_pool.get_browser()
            # Create context ID
            context_id = str(uuid.uuid4())
            # Create the context
            context = await browser_instance.create_context(
                context_id,
                user_id=user_id
            )
            # Store the mapping
            self.session_contexts[session_id] = {
                "context_id": context_id,
                "browser_id": browser_instance.id,
                "created_at": time.time(),
                "user_id": user_id
            }
            logger.info(f"Created browser context {context_id} for session {session_id}")
            return context
        except Exception as e:
            logger.error(f"Error creating browser context: {str(e)}")
            raise MCPBrowserException(
                error_code=ErrorCode.RESOURCE_POOL_EXHAUSTED,
                message=f"Failed to create browser context: {str(e)}",
                original_exception=e
            )
    async def get_browser_context(self, session_id: str) -> Dict[str, Any]:
        """
        Get the browser context for a session
        Args:
            session_id: Session identifier
        Returns:
            Context information
        """
        session_info = self.session_contexts.get(session_id)
        if not session_info:
            raise MCPBrowserException(
                error_code=ErrorCode.RESOURCE_NOT_FOUND,
                message=f"No browser context found for session {session_id}"
            )
        return session_info
    async def close_browser_context(self, session_id: str):
        """
        Close the browser context for a session
        Args:
            session_id: Session identifier
        """
        session_info = self.session_contexts.get(session_id)
        if not session_info:
            logger.warning(f"No browser context found for session {session_id}")
            return
        context_id = session_info["context_id"]
        browser_id = session_info["browser_id"]
        try:
            # Get the browser instance
            browser = browser_pool.browsers.get(browser_id)
            if browser:
                # Close the context
                await browser.close_context(context_id)
            # Remove the session mapping
            del self.session_contexts[session_id]
            logger.info(f"Closed browser context for session {session_id}")
        except Exception as e:
            logger.error(f"Error closing browser context: {str(e)}")
            # Still remove the session mapping
            if session_id in self.session_contexts:
                del self.session_contexts[session_id]
class AuthManager:
    """Manager for authentication and authorization"""
    def __init__(self):
        """Initialize the auth manager"""
        pass
    async def get_user(self, username: str) -> Optional[User]:
        """
        Get a user by username
        Args:
            username: Username
        Returns:
            User object or None if not found
        """
        user_data = fake_users_db.get(username)
        if user_data:
            return User(**user_data)
        return None
    async def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """
        Authenticate a user
        Args:
            username: Username
            password: Password
        Returns:
            User object if authentication succeeds, None otherwise
        """
        # For demo, any password works
        user = await self.get_user(username)
        if not user:
            return None
        return user
    async def create_access_token(
        self, 
        data: Dict[str, Any], 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """
        Create an access token
        Args:
            data: Claims to include in the token
            expires_delta: Token expiration time
        Returns:
            JWT token
        """
        to_encode = data.copy()
        # Set expiration
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})
        # Create the token
        encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
        return encoded_jwt
    async def create_refresh_token(self, data: Dict[str, Any]) -> str:
        """
        Create a refresh token
        Args:
            data: Claims to include in the token
        Returns:
            JWT token
        """
        to_encode = data.copy()
        # Set expiration
        expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
        to_encode.update({"exp": expire, "refresh": True})
        # Create the token
        encoded_jwt = jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
        return encoded_jwt
    async def decode_token(self, token: str) -> Dict[str, Any]:
        """
        Decode a JWT token
        Args:
            token: JWT token
        Returns:
            Token claims
        Raises:
            MCPBrowserException: If token is invalid
        """
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
            return payload
        except jwt.ExpiredSignatureError:
            raise MCPBrowserException(
                error_code=ErrorCode.AUTH_TOKEN_EXPIRED,
                message="Token has expired"
            )
        except jwt.InvalidTokenError:
            raise MCPBrowserException(
                error_code=ErrorCode.AUTH_INVALID_TOKEN,
                message="Invalid token"
            )
    async def get_current_user(self, token: str = Depends(oauth2_scheme)) -> User:
        """
        Get the current user from a token
        Args:
            token: JWT token
        Returns:
            User object
        Raises:
            HTTPException: If token is invalid or user not found
        """
        try:
            payload = await self.decode_token(token)
            username = payload.get("sub")
            if username is None:
                raise MCPBrowserException(
                    error_code=ErrorCode.AUTH_INVALID_TOKEN,
                    message="Token missing username"
                )
            user = await self.get_user(username)
            if user is None:
                raise MCPBrowserException(
                    error_code=ErrorCode.AUTH_INVALID_TOKEN,
                    message="User not found"
                )
            return user
        except MCPBrowserException as e:
            raise e.to_http_exception()
    async def get_current_active_user(self, current_user: User = Depends(get_current_user)) -> User:
        """
        Check if the current user is active
        Args:
            current_user: User object
        Returns:
            User object if active
        Raises:
            HTTPException: If user is disabled
        """
        if current_user.disabled:
            raise MCPBrowserException(
                error_code=ErrorCode.AUTH_USER_DISABLED,
                message="Inactive user"
            ).to_http_exception()
        return current_user
    def has_permission(self, user: User, required_permission: str) -> bool:
        """
        Check if a user has a permission
        Args:
            user: User object
            required_permission: Required permission
        Returns:
            True if user has permission, False otherwise
        """
        return required_permission in user.permissions or "admin" in user.permissions
# Create global instances
browser_manager = BrowserManager()
auth_manager = AuthManager()
def configure_app(app: FastAPI) -> FastAPI:
    """
    Configure the FastAPI app with lifespan event handlers
    Args:
        app: FastAPI app
    Returns:
        FastAPI app with lifespan configured
    """
    # Define lifespan context manager for this app
    @asynccontextmanager
    async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
        """Lifespan context manager for startup and shutdown events"""
        # Startup: Initialize services
        max_browsers = int(os.environ.get("MAX_BROWSERS", 10))
        idle_timeout = int(os.environ.get("IDLE_TIMEOUT", 300))
        await browser_manager.initialize(max_browsers, idle_timeout)
        logger.info("Integration services initialized")
        yield  # Run the application
        # Shutdown: Clean up resources
        await browser_manager.shutdown()
        logger.info("Integration services shut down")
    # Configure app with lifespan
    app.router.lifespan_context = lifespan
    return app
# Export components and functions
__all__ = [
    "browser_manager",
    "auth_manager",
    "configure_app",
    "with_retry",
    "handle_exceptions",
    "DEFAULT_RETRY_CONFIG"
]
</file>

<file path="src/main.py">
#!/usr/bin/env python3
"""
MCP Browser - A browser automation server
This module provides a FastAPI server with browser automation capabilities.
"""
import os
import logging
from typing import Dict, List, Optional, Any, AsyncGenerator
import json
import time
import uvicorn
from fastapi import FastAPI, HTTPException, Depends, WebSocket, status, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel
from contextlib import asynccontextmanager
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("mcp-browser")
# App state
app_state = {}
# Models
class Token(BaseModel):
    access_token: str
    token_type: str
class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    disabled: Optional[bool] = None
    permissions: List[str] = []
class BrowserNavigation(BaseModel):
    url: str
    timeout: Optional[int] = 30
    wait_until: Optional[str] = "networkidle"
class BrowserSelector(BaseModel):
    selector: str
    timeout: Optional[int] = 30
class BrowserClick(BrowserSelector):
    force: Optional[bool] = False
class BrowserType(BrowserSelector):
    text: str
    delay: Optional[int] = 0
# Define lifespan context manager
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Lifespan context manager for startup and shutdown events"""
    global app_state
    # Startup: Initialize services
    app_state = {}
    # Initialize app state here
    logger.info("MCP Browser server started")
    yield  # Run the application
    # Shutdown: Cleanup resources
    # Cleanup resources here
    logger.info("MCP Browser server shut down")
# Create FastAPI app with lifespan
app = FastAPI(
    title="MCP Browser",
    description="Browser automation server for MCP",
    version="0.1.0",
    lifespan=lifespan
)
# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Define auth functions
def create_access_token(data: dict, expires_delta: Optional[int] = None):
    """Create a JWT access token"""
    # This is a placeholder for the real implementation
    return "placeholder_token"
async def get_current_user(token: str):
    """Get the current user from JWT token"""
    # This is a placeholder for the real implementation
    return User(username="test_user", permissions=["browser:full"])
async def get_current_active_user(current_user: User = Depends(get_current_user)):
    """Check if the user is active"""
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
# Endpoints
@app.get("/", response_class=HTMLResponse)
async def root():
    """Root endpoint with HTML response"""
    return """
    <html>
    <head>
        <title>MCP Browser</title>
    </head>
    <body>
            <h1>MCP Browser Server</h1>
            <p>Browser automation server for MCP</p>
    </body>
    </html>
    """
@app.get("/api/status")
async def status():
    """Get server status"""
    return {"status": "ok"}
@app.post("/token", response_model=Token)
async def login_for_access_token(username: str = Body(...), password: str = Body(...)):
    """Generate access token for API authentication"""
    # This is a placeholder for the real authentication
    access_token = create_access_token(
        data={"sub": username, "permissions": ["browser:full"]}
    )
    return {"access_token": access_token, "token_type": "bearer"}
@app.get("/users/me", response_model=User)
async def get_user_me(current_user: User = Depends(get_current_active_user)):
    """Get current user information"""
    return current_user
@app.post("/api/browser/navigate")
async def navigate(params: BrowserNavigation, current_user: User = Depends(get_current_active_user)):
    """Navigate to URL"""
    logger.info(f"Navigating to {params.url}")
    return {"status": "success", "url": params.url}
@app.post("/api/browser/back")
async def back(current_user: User = Depends(get_current_active_user)):
    """Go back in browser history"""
    logger.info("Going back in history")
    return {"status": "success"}
@app.post("/api/browser/forward")
async def forward(current_user: User = Depends(get_current_active_user)):
    """Go forward in browser history"""
    logger.info("Going forward in history")
    return {"status": "success"}
@app.post("/api/browser/refresh")
async def refresh(current_user: User = Depends(get_current_active_user)):
    """Refresh current page"""
    logger.info("Refreshing page")
    return {"status": "success"}
@app.post("/api/browser/click")
async def click(params: BrowserClick, current_user: User = Depends(get_current_active_user)):
    """Click on element"""
    logger.info(f"Clicking element: {params.selector}")
    return {"status": "success", "selector": params.selector}
@app.post("/api/browser/type")
async def type_text(params: BrowserType, current_user: User = Depends(get_current_active_user)):
    """Type text into element"""
    logger.info(f"Typing '{params.text}' into element: {params.selector}")
    return {"status": "success", "selector": params.selector, "text": params.text}
# WebSocket endpoints
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time communication"""
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Echo: {data}")
    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
    finally:
        await websocket.close()
@app.websocket("/ws/browser/events")
async def websocket_browser_events(websocket: WebSocket):
    """WebSocket endpoint for browser event subscriptions"""
    await websocket.accept()
    # Generate a unique client ID
    client_id = f"client_{int(time.time())}"
    try:
        # Send welcome message
        await websocket.send_json({
            "type": "connection",
            "client_id": client_id,
            "message": "Connected to MCP Browser Event Subscription Service",
            "timestamp": time.time()
        })
        # Process messages
        while True:
            data = await websocket.receive_text()
            try:
                message = json.loads(data)
                action = message.get("action", "")
                if action == "subscribe":
                    # Handle subscription request
                    event_types = message.get("event_types", [])
                    subscription_id = f"sub_{int(time.time())}"
                    # Send subscription confirmation
                    await websocket.send_json({
                        "type": "subscription",
                        "subscription_id": subscription_id,
                        "event_types": event_types,
                        "timestamp": time.time()
                    })
                elif action == "execute":
                    # Handle execute command
                    command = message.get("command", "")
                    params = message.get("params", {})
                    # Send command acknowledgment
                    await websocket.send_json({
                        "type": "command_executed",
                        "command": command,
                        "success": True,
                        "timestamp": time.time()
                    })
                    # If navigation command, send simulated page load event
                    if command == "navigate" and "url" in params:
                        await websocket.send_json({
                            "type": "PAGE",
                            "event": "page.load",
                            "timestamp": time.time(),
                            "data": {
                                "url": params["url"],
                                "title": f"Page Title for {params['url']}",
                                "status": 200,
                                "timestamp": time.time()
                            }
                        })
                else:
                    # Echo unknown messages
                    await websocket.send_text(f"Echo: {data}")
            except json.JSONDecodeError:
                await websocket.send_text(f"Invalid JSON: {data}")
    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
    finally:
        await websocket.close()
# Run server
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=os.environ.get("HOST", "0.0.0.0"),
        port=int(os.environ.get("PORT", 8000)),
        reload=bool(os.environ.get("RELOAD", True))
    )
</file>

<file path="src/simple_test.py">
#!/usr/bin/env python3
"""
Simple test script for MCP Browser API endpoints
"""
import os
import sys
import requests
import json
from datetime import datetime
# API Base URL
API_BASE_URL = "http://localhost:7665"
def log_message(msg):
    """Log a message with timestamp"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {msg}")
def check_api_status():
    """Check if the API is running"""
    try:
        response = requests.get(f"{API_BASE_URL}/api/status")
        if response.status_code == 200:
            log_message(f"API Status: {response.json()}")
            return True
        else:
            log_message(f"API Status check failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error checking API status: {e}")
        return False
def test_api():
    """Run basic API test"""
    log_message("Starting API test...")
    # Check if API is running
    if not check_api_status():
        log_message("API is not running or not responding. Aborting test.")
        return False
    log_message("API is running. Basic test passed!")
    return True
if __name__ == "__main__":
    success = test_api()
    sys.exit(0 if success else 1)
</file>

<file path="src/test_api.py">
#!/usr/bin/env python3
"""
Test script for MCP Browser API endpoints
"""
import os
import sys
import requests
import json
import base64
import time
from datetime import datetime
# API Base URL - can be overridden by environment variable
API_BASE_URL = os.environ.get("API_BASE_URL", "http://localhost:7665")
# Output directories
OUTPUT_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "output")
SCREENSHOTS_DIR = os.path.join(OUTPUT_DIR, "screenshots")
DOM_DIR = os.path.join(OUTPUT_DIR, "dom")
CSS_DIR = os.path.join(OUTPUT_DIR, "css")
# Create output directories if they don't exist
os.makedirs(SCREENSHOTS_DIR, exist_ok=True)
os.makedirs(DOM_DIR, exist_ok=True)
os.makedirs(CSS_DIR, exist_ok=True)
def log_message(msg):
    """Log a message with timestamp"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {msg}")
def check_api_status():
    """Check if the API is running"""
    try:
        response = requests.get(f"{API_BASE_URL}/api/status")
        if response.status_code == 200:
            status_data = response.json()
            log_message(f"API Status: {status_data}")
            return True
        else:
            log_message(f"API Status check failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error checking API status: {e}")
        return False
def test_screenshot_capture():
    """Test the screenshot capture API"""
    log_message("Testing screenshot capture API...")
    # Test parameters
    test_url = "https://example.com"
    viewport = {"width": 1280, "height": 800}
    try:
        response = requests.post(
            f"{API_BASE_URL}/api/screenshots/capture",
            params={
                "url": test_url,
                "full_page": True,
                "format": "png"
            },
            json={
                "viewport": viewport
            }
        )
        if response.status_code == 200:
            result = response.json()
            if result.get("success"):
                # Save the screenshot to a file for verification
                if "screenshot" in result:
                    img_data = base64.b64decode(result["screenshot"])
                    timestamp = int(time.time())
                    filename = f"screenshot_{timestamp}.png"
                    filepath = os.path.join(SCREENSHOTS_DIR, filename)
                    with open(filepath, "wb") as f:
                        f.write(img_data)
                    log_message(f"Screenshot saved to {filepath}")
                    return True
                else:
                    log_message("Screenshot data missing from response")
                    return False
            else:
                log_message(f"Screenshot capture failed: {result.get('error', 'Unknown error')}")
                return False
        else:
            log_message(f"API request failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error testing screenshot capture: {e}")
        return False
def test_dom_extraction():
    """Test the DOM extraction API"""
    log_message("Testing DOM extraction API...")
    # Test parameters
    test_url = "https://example.com"
    selector = "h1"  # Example.com has an h1 element
    try:
        response = requests.post(
            f"{API_BASE_URL}/api/dom/extract",
            params={
                "url": test_url,
                "selector": selector,
                "include_styles": True,
                "include_attributes": True
            }
        )
        if response.status_code == 200:
            result = response.json()
            if result.get("success"):
                # Save the DOM info to a file for verification
                if "dom" in result:
                    timestamp = int(time.time())
                    filename = f"dom_extraction_{timestamp}.json"
                    filepath = os.path.join(DOM_DIR, filename)
                    with open(filepath, "w") as f:
                        json.dump(result["dom"], f, indent=2)
                    log_message(f"DOM extraction saved to {filepath}")
                    return True
                else:
                    log_message("DOM data missing from response")
                    return False
            else:
                log_message(f"DOM extraction failed: {result.get('error', 'Unknown error')}")
                return False
        else:
            log_message(f"API request failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error testing DOM extraction: {e}")
        return False
def test_css_analysis():
    """Test the CSS analysis API"""
    log_message("Testing CSS analysis API...")
    # Test parameters
    url = "https://example.com"
    selector = "p"
    check_accessibility = True
    try:
        # Make the API call
        response = requests.post(
            f"{API_BASE_URL}/api/css/analyze",
            params={"url": url, "selector": selector, "check_accessibility": check_accessibility}
        )
        # Check response
        if response.status_code == 200:
            css_data = response.json()
            log_message(f"CSS analysis successful")
            # Save the response to file
            timestamp = int(time.time())
            output_file = os.path.join(CSS_DIR, f"css_analysis_{timestamp}.json")
            with open(output_file, "w") as f:
                json.dump(css_data, f, indent=2)
            log_message(f"CSS analysis data saved to {output_file}")
            return True
        else:
            log_message(f"CSS analysis failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error testing CSS analysis API: {e}")
        return False
def test_accessibility():
    """Test the accessibility testing API"""
    log_message("Testing accessibility testing API...")
    # Test parameters
    url = "https://example.com"
    standard = "wcag2aa"
    include_html = True
    include_warnings = True
    try:
        # Make the API call
        response = requests.post(
            f"{API_BASE_URL}/api/accessibility/test",
            params={
                "url": url, 
                "standard": standard, 
                "include_html": include_html,
                "include_warnings": include_warnings
            }
        )
        # Check response
        if response.status_code == 200:
            accessibility_data = response.json()
            log_message(f"Accessibility testing successful")
            # Save the response to file
            timestamp = int(time.time())
            output_dir = os.path.join(OUTPUT_DIR, "accessibility")
            os.makedirs(output_dir, exist_ok=True)
            output_file = os.path.join(output_dir, f"accessibility_test_{timestamp}.json")
            with open(output_file, "w") as f:
                json.dump(accessibility_data, f, indent=2)
            log_message(f"Accessibility test data saved to {output_file}")
            return True
        else:
            log_message(f"Accessibility testing failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error testing accessibility API: {e}")
        return False
def test_responsive():
    """Test the responsive design testing API"""
    log_message("Testing responsive design testing API...")
    # Test parameters
    url = "https://example.com"
    viewports = [
        {"width": 375, "height": 667},  # Mobile
        {"width": 1366, "height": 768}  # Laptop
    ]
    selectors = ["h1", "p"]
    try:
        # Make the API call
        response = requests.post(
            f"{API_BASE_URL}/api/responsive/test",
            params={
                "url": url,
                "include_screenshots": True,
                "compare_elements": True
            },
            json={
                "viewports": viewports,
                "selectors": selectors
            }
        )
        # Check response
        if response.status_code == 200:
            responsive_data = response.json()
            log_message(f"Responsive design testing successful")
            # Save the response to file
            timestamp = int(time.time())
            output_dir = os.path.join(OUTPUT_DIR, "responsive")
            os.makedirs(output_dir, exist_ok=True)
            output_file = os.path.join(output_dir, f"responsive_test_summary_{timestamp}.json")
            with open(output_file, "w") as f:
                json.dump(responsive_data, f, indent=2)
            log_message(f"Responsive test data saved to {output_file}")
            return True
        else:
            log_message(f"Responsive design testing failed: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        log_message(f"Error testing responsive design API: {e}")
        return False
def run_tests():
    """Run all the API tests"""
    # Check if the API is running
    if not check_api_status():
        log_message("API is not running. Exiting.")
        sys.exit(1)
    # Keep track of test results
    test_results = {
        "screenshot_capture": None,
        "dom_extraction": None,
        "css_analysis": None,
        "accessibility_testing": None,
        "responsive_testing": None
    }
    # Run tests
    test_results["screenshot_capture"] = test_screenshot_capture()
    test_results["dom_extraction"] = test_dom_extraction()
    test_results["css_analysis"] = test_css_analysis()
    test_results["accessibility_testing"] = test_accessibility()
    test_results["responsive_testing"] = test_responsive()
    # Report results
    log_message("\n--- Test Results ---")
    all_passed = True
    for test_name, result in test_results.items():
        status = "PASSED" if result else "FAILED"
        log_message(f"{test_name}: {status}")
        if not result:
            all_passed = False
    # Exit with appropriate status code
    if all_passed:
        log_message("All tests passed!")
        sys.exit(0)
    else:
        log_message("Some tests failed. Check the logs for details.")
        sys.exit(1)
if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1)
</file>

<file path="src/test_event_subscription.py">
#!/usr/bin/env python3
"""
Test script for MCP Browser WebSocket event subscriptions
This script connects to the MCP Browser server's WebSocket event endpoint,
subscribes to browser events, and displays them in real-time.
"""
import asyncio
import json
import sys
import argparse
import logging
import websockets
from datetime import datetime
# Try to import colorama for colored output
try:
    from colorama import Fore, Style, init
    # Initialize colorama
    init()
    HAS_COLORAMA = True
except ImportError:
    # Fallback if colorama is not available
    print("Warning: colorama not found. Using plain text output.")
    HAS_COLORAMA = False
    # Create dummy color objects
    class DummyColors:
        def __getattr__(self, name):
            return ""
    Fore = DummyColors()
    Style = DummyColors()
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)
# Event type colors
EVENT_COLORS = {
    "PAGE": Fore.BLUE,
    "NETWORK": Fore.CYAN,
    "CONSOLE": Fore.GREEN,
    "DOM": Fore.MAGENTA,
    "ERROR": Fore.RED,
    "DEFAULT": Fore.WHITE,
}
# Parse command line arguments
parser = argparse.ArgumentParser(description="MCP Browser Event Subscription Test")
parser.add_argument(
    "--url", "-s", 
    default="ws://localhost:7665/ws/browser/events", 
    help="WebSocket URL for the browser events endpoint"
)
parser.add_argument(
    "--types", "-t", 
    default="PAGE,NETWORK,CONSOLE,DOM", 
    help="Comma-separated list of event types to subscribe to"
)
parser.add_argument(
    "--filter-url", "-f", 
    default="", 
    help="Filter events by URL pattern"
)
parser.add_argument(
    "--target-url", 
    default="", 
    help="URL to navigate to after connecting"
)
parser.add_argument(
    "--timeout", 
    type=int, 
    default=0, 
    help="Exit after this many seconds (0 means run indefinitely)"
)
args = parser.parse_args()
async def subscribe_to_events(ws, event_types, url_pattern=None):
    """Subscribe to browser events"""
    subscription_data = {
        "action": "subscribe",
        "event_types": event_types.split(","),
    }
    if url_pattern:
        subscription_data["filters"] = {"url_pattern": url_pattern}
    await ws.send(json.dumps(subscription_data))
    response = await ws.recv()
    logger.info(f"Subscription response: {response}")
    return json.loads(response)
async def print_event(event_data):
    """Format and print an event"""
    try:
        event_json = json.loads(event_data)
        timestamp = datetime.fromtimestamp(event_json.get("timestamp", 0)).strftime("%H:%M:%S")
        event_type = event_json.get("type", "DEFAULT")
        event_name = event_json.get("event", "unknown")
        page_id = event_json.get("page_id", "unknown")
        data = event_json.get("data", {})
        # Get the appropriate color
        color = EVENT_COLORS.get(event_type, EVENT_COLORS["DEFAULT"])
        # Print the event
        print(f"{color}[{timestamp}] {event_type}.{event_name} {Style.RESET_ALL}")
        # Format the data nicely
        if isinstance(data, dict):
            for key, value in data.items():
                # Handle nested data for better display
                if isinstance(value, dict) and len(value) > 0:
                    print(f"  {key}:")
                    for subkey, subvalue in value.items():
                        if isinstance(subvalue, str) and len(subvalue) > 100:
                            subvalue = subvalue[:100] + "..."
                        print(f"    {subkey}: {subvalue}")
                else:
                    if isinstance(value, str) and len(value) > 100:
                        value = value[:100] + "..."
                    print(f"  {key}: {value}")
        else:
            print(f"  {data}")
        print("-" * 80)
    except Exception as e:
        logger.error(f"Error processing event: {e}")
        logger.error(f"Raw event data: {event_data}")
async def timeout_handler():
    """Handle timeout and exit gracefully"""
    if args.timeout > 0:
        logger.info(f"Will exit after {args.timeout} seconds")
        await asyncio.sleep(args.timeout)
        logger.info("Timeout reached, exiting")
        print(f"\n{Fore.YELLOW}Test completed after {args.timeout} seconds{Style.RESET_ALL}")
        sys.exit(0)
async def main():
    """Main function"""
    try:
        logger.info(f"Connecting to WebSocket at {args.url}")
        # Start timeout handler if specified
        if args.timeout > 0:
            asyncio.create_task(timeout_handler())
        async with websockets.connect(args.url) as ws:
            logger.info("Connected to WebSocket server")
            # Subscribe to events
            subscription = await subscribe_to_events(ws, args.types, args.filter_url)
            subscription_id = subscription.get("subscription_id", "unknown")
            logger.info(f"Subscribed to events with ID: {subscription_id}")
            # Navigate to target URL if provided
            if args.target_url:
                navigate_msg = {
                    "action": "execute",
                    "command": "navigate",
                    "params": {"url": args.target_url}
                }
                await ws.send(json.dumps(navigate_msg))
                logger.info(f"Navigating to {args.target_url}")
            # Print initial message
            print("\n" + "=" * 80)
            print(f"{Fore.YELLOW}MCP Browser Event Subscription Test{Style.RESET_ALL}")
            print(f"Listening for events of types: {args.types}")
            if args.filter_url:
                print(f"Filtering by URL pattern: {args.filter_url}")
            if args.timeout > 0:
                print(f"Will exit after {args.timeout} seconds")
            print("=" * 80 + "\n")
            # Receive events
            while True:
                message = await ws.recv()
                await print_event(message)
    except websockets.exceptions.ConnectionClosed:
        logger.error("WebSocket connection closed")
    except Exception as e:
        logger.error(f"Error: {e}")
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nScript terminated by user")
        sys.exit(0)
</file>

<file path="src/test_events.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MCP Browser Events Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      h1 {
        color: #333;
      }
      .control-panel {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f8f8f8;
      }
      button {
        padding: 8px 15px;
        margin-right: 10px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover {
        background-color: #45a049;
      }
      #eventLog {
        margin-top: 20px;
        height: 300px;
        overflow-y: auto;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f5f5f5;
      }
      .event {
        margin-bottom: 5px;
        padding: 5px;
        border-bottom: 1px solid #eee;
      }
      .error {
        color: red;
      }
      .warning {
        color: orange;
      }
      .info {
        color: blue;
      }
    </style>
  </head>
  <body>
    <h1>MCP Browser Events Test</h1>
    <div class="control-panel">
      <h2>Event Generators</h2>
      <button id="btnConsoleLog">Console Log</button>
      <button id="btnConsoleError">Console Error</button>
      <button id="btnConsoleWarn">Console Warning</button>
      <button id="btnAjaxRequest">AJAX Request</button>
      <button id="btnDOMChange">Change DOM</button>
      <button id="btnNavigate">Simulate Navigation</button>
    </div>
    <div class="control-panel">
      <h2>Dynamic Content</h2>
      <div id="dynamicContent">
        <p>This content will change when you click the "Change DOM" button.</p>
      </div>
    </div>
    <div>
      <h2>Event Log</h2>
      <div id="eventLog"></div>
    </div>
    <script>
      // Helper function to log events
      function logEvent(message, type = "info") {
        const eventLog = document.getElementById("eventLog");
        const eventElement = document.createElement("div");
        eventElement.className = `event ${type}`;
        eventElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        eventLog.prepend(eventElement);
      }
      // Console events
      document.getElementById("btnConsoleLog").addEventListener("click", () => {
        console.log("This is a console log message");
        logEvent("Console log message sent");
      });
      document
        .getElementById("btnConsoleError")
        .addEventListener("click", () => {
          console.error("This is a console error message");
          logEvent("Console error message sent", "error");
        });
      document
        .getElementById("btnConsoleWarn")
        .addEventListener("click", () => {
          console.warn("This is a console warning message");
          logEvent("Console warning message sent", "warning");
        });
      // AJAX request
      document
        .getElementById("btnAjaxRequest")
        .addEventListener("click", () => {
          logEvent("Making AJAX request to example.com");
          fetch("https://example.com")
            .then((response) => {
              logEvent(
                `Received response: ${response.status} ${response.statusText}`
              );
              return response.text();
            })
            .catch((error) => {
              logEvent(`Request failed: ${error}`, "error");
            });
        });
      // DOM changes
      document.getElementById("btnDOMChange").addEventListener("click", () => {
        const dynamicContent = document.getElementById("dynamicContent");
        // Create new elements
        const newParagraph = document.createElement("p");
        newParagraph.textContent = `New paragraph added at ${new Date().toLocaleTimeString()}`;
        // Change attribute
        newParagraph.setAttribute("data-timestamp", Date.now());
        // Add to DOM
        dynamicContent.appendChild(newParagraph);
        // Change existing content
        const existingParagraphs = dynamicContent.querySelectorAll("p");
        if (existingParagraphs.length > 1) {
          existingParagraphs[0].style.color = getRandomColor();
        }
        logEvent("DOM changed");
      });
      // Simulate navigation
      document.getElementById("btnNavigate").addEventListener("click", () => {
        logEvent("Simulating navigation with window.history");
        // Push a new state to the history
        const state = { page: Math.floor(Math.random() * 100) };
        const title = "Page " + state.page;
        const url = `?page=${state.page}`;
        window.history.pushState(state, title, url);
        document.title = "MCP Browser Events Test - " + title;
        logEvent(`Navigation simulated to: ${url}`);
      });
      // Helper function to generate random colors
      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }
      // Log page load
      window.addEventListener("load", () => {
        logEvent("Page loaded");
      });
      // Log history changes
      window.addEventListener("popstate", (event) => {
        logEvent(`Navigation state changed: ${JSON.stringify(event.state)}`);
      });
    </script>
  </body>
</html>
</file>

<file path="src/test_integration.py">
#!/usr/bin/env python3
"""
Integration Test for MCP Browser Components
This script tests that all components work together properly.
"""
import asyncio
import json
import logging
import os
import sys
from typing import Dict, Any, List, Optional
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("integration-test")
# Import our components
from browser_pool import browser_pool, initialize_browser_pool, close_browser_pool
from error_handler import (
    MCPBrowserException, ErrorCode, RetryConfig, with_retry, handle_exceptions, DEFAULT_RETRY_CONFIG
)
from integration import browser_manager, auth_manager
async def test_browser_pool():
    """Test the browser pool component"""
    logger.info("Testing browser pool...")
    # Initialize browser pool
    await initialize_browser_pool(max_browsers=2)
    # Get a browser instance
    browser = await browser_pool.get_browser()
    assert browser is not None, "Failed to get browser instance"
    logger.info(f"Got browser instance: {browser.id}")
    # Create a context
    context_id = "test-context"
    context = await browser.create_context(context_id)
    assert context is not None, "Failed to create browser context"
    logger.info(f"Created browser context: {context_id}")
    # Close the context
    await browser.close_context(context_id)
    logger.info(f"Closed browser context: {context_id}")
    # Get another browser (should reuse the instance)
    browser2 = await browser_pool.get_browser()
    assert browser2 is not None, "Failed to get second browser instance"
    logger.info(f"Got second browser instance: {browser2.id}")
    # Close browser pool
    await close_browser_pool()
    logger.info("Browser pool test passed")
async def test_error_handler():
    """Test the error handler component"""
    logger.info("Testing error handler...")
    # Test creating an exception
    try:
        raise MCPBrowserException(
            error_code=ErrorCode.BROWSER_ELEMENT_NOT_FOUND,
            message="Test error message",
            details=[{"field": "selector", "message": "Element not found", "code": "404"}]
        )
    except MCPBrowserException as e:
        # Convert to response
        response = e.to_response()
        assert response.error_code == ErrorCode.BROWSER_ELEMENT_NOT_FOUND.value, "Wrong error code"
        assert response.message == "Test error message", "Wrong error message"
        logger.info(f"Exception properly created: {response.error_code} - {response.message}")
    # Test retry mechanism
    retry_count = 0
    async def failing_func():
        nonlocal retry_count
        retry_count += 1
        if retry_count < 3:
            raise MCPBrowserException(
                error_code=ErrorCode.BROWSER_TIMEOUT,
                message=f"Timeout error (attempt {retry_count})"
            )
        return "Success"
    result = await with_retry(
        failing_func,
        retry_config=RetryConfig(max_retries=3, initial_delay=0.1, max_delay=0.5)
    )
    assert result == "Success", "Retry mechanism failed"
    assert retry_count == 3, f"Wrong retry count: {retry_count}"
    logger.info(f"Retry mechanism worked properly after {retry_count} attempts")
    # Test decorator
    @handle_exceptions
    async def test_decorator():
        raise MCPBrowserException(
            error_code=ErrorCode.VALIDATION_ERROR,
            message="Validation error"
        )
    try:
        await test_decorator()
        assert False, "Decorator did not raise exception"
    except Exception as e:
        assert hasattr(e, "status_code"), "Exception not converted to HTTP exception"
        logger.info("Exception decorator works properly")
    logger.info("Error handler test passed")
async def test_integration():
    """Test the integration component"""
    logger.info("Testing integration...")
    # Test browser manager
    await browser_manager.initialize(max_browsers=2)
    # Create a session
    session_id = "test-session"
    context = await browser_manager.create_browser_context(session_id, "test-user")
    assert context is not None, "Failed to create browser context"
    logger.info(f"Created browser context for session: {session_id}")
    # Get the context
    session_info = await browser_manager.get_browser_context(session_id)
    assert session_info is not None, "Failed to get browser context"
    assert session_info["user_id"] == "test-user", "Wrong user ID"
    logger.info(f"Got browser context for session: {session_id}")
    # Close the context
    await browser_manager.close_browser_context(session_id)
    logger.info(f"Closed browser context for session: {session_id}")
    # Test auth manager
    username = "admin"
    user = await auth_manager.get_user(username)
    assert user is not None, "Failed to get user"
    assert user.username == username, "Wrong username"
    logger.info(f"Got user: {user.username}")
    # Test token creation and decoding
    token_data = {"sub": username, "permissions": user.permissions}
    access_token = await auth_manager.create_access_token(token_data)
    assert access_token is not None, "Failed to create access token"
    logger.info(f"Created access token")
    # Decode token
    payload = await auth_manager.decode_token(access_token)
    assert payload["sub"] == username, "Wrong username in token"
    logger.info(f"Decoded token: {payload['sub']}")
    # Test permission check
    has_permission = auth_manager.has_permission(user, "browser:full")
    assert has_permission, "User should have permission"
    logger.info(f"User has permission: browser:full")
    # Clean up
    await browser_manager.shutdown()
    logger.info("Integration test passed")
async def main():
    """Run all tests"""
    try:
        logger.info("Starting integration tests...")
        # Run tests
        await test_browser_pool()
        await test_error_handler()
        await test_integration()
        logger.info("All tests passed!")
        return 0
    except Exception as e:
        logger.error(f"Test failed: {str(e)}", exc_info=True)
        return 1
if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
</file>

<file path="src/test_lifespan.py">
#!/usr/bin/env python3
"""
Test file to verify lifespan events are working correctly.
This is a simplified version of the main application with lifespan events.
"""
import asyncio
import logging
from typing import AsyncGenerator
from contextlib import asynccontextmanager
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("test-lifespan")
# App state
app_state = {}
# Define lifespan context manager
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Lifespan context manager for startup and shutdown events"""
    global app_state
    # Startup: Initialize services
    app_state["initialized"] = True
    app_state["start_time"] = asyncio.get_event_loop().time()
    logger.info("Test server started with lifespan event")
    yield  # Run the application
    # Shutdown: Cleanup resources
    app_state["shutdown_time"] = asyncio.get_event_loop().time()
    app_state["uptime"] = app_state["shutdown_time"] - app_state["start_time"]
    logger.info(f"Test server shut down. Uptime: {app_state['uptime']:.2f} seconds")
# Create FastAPI app with lifespan
app = FastAPI(
    title="Lifespan Test",
    description="Test server for lifespan events",
    version="0.1.0",
    lifespan=lifespan
)
# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Endpoints
@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "Lifespan Test Server",
        "initialized": app_state.get("initialized", False),
        "uptime": asyncio.get_event_loop().time() - app_state.get("start_time", 0)
    }
@app.get("/state")
async def state():
    """Get app state"""
    return app_state
# Main entry point
if __name__ == "__main__":
    uvicorn.run("test_lifespan:app", host="0.0.0.0", port=8766, reload=False)
</file>

<file path="src/test_websocket_client.py">
#!/usr/bin/env python3
"""
WebSocket client for testing the WebSocket event subscription feature.
This connects to the test WebSocket server, subscribes to events, and displays them.
"""
import asyncio
import json
import logging
import sys
import argparse
import websockets
from datetime import datetime
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)
# Parse command line arguments
parser = argparse.ArgumentParser(description="WebSocket Event Subscription Test Client")
parser.add_argument(
    "--url", 
    default="ws://localhost:8765/ws/events", 
    help="WebSocket URL for the event endpoint"
)
parser.add_argument(
    "--types", 
    default="PAGE,NETWORK,CONSOLE,DOM", 
    help="Comma-separated list of event types to subscribe to"
)
parser.add_argument(
    "--test-events", 
    action="store_true", 
    help="Generate test events periodically"
)
parser.add_argument(
    "--timeout", 
    type=int, 
    default=0, 
    help="Exit after this many seconds (0 means run indefinitely)"
)
args = parser.parse_args()
async def subscribe_to_events(ws, event_types):
    """Subscribe to events"""
    subscription_data = {
        "action": "subscribe",
        "event_types": event_types.split(","),
    }
    await ws.send(json.dumps(subscription_data))
    response = await ws.recv()
    logger.info(f"Subscription response: {response}")
    return json.loads(response)
async def generate_test_event(ws, event_type="PAGE", event_name="test.event"):
    """Generate a test event"""
    test_event_data = {
        "action": "test_event",
        "event_type": event_type,
        "event_name": event_name,
        "data": {
            "message": f"Test event: {event_type}.{event_name}",
            "timestamp": datetime.now().strftime("%H:%M:%S"),
            "details": {
                "test": True,
                "generated_at": str(datetime.now())
            }
        }
    }
    await ws.send(json.dumps(test_event_data))
    response = await ws.recv()
    logger.info(f"Test event response: {response}")
async def print_event(event_data):
    """Format and print an event"""
    try:
        event_json = json.loads(event_data)
        event_type = event_json.get("type", "DEFAULT")
        event_name = event_json.get("event", "unknown")
        timestamp = datetime.fromtimestamp(event_json.get("timestamp", 0)).strftime("%H:%M:%S")
        data = event_json.get("data", {})
        # Print the event
        print(f"[{timestamp}] {event_type}.{event_name}")
        # Format the data nicely
        if isinstance(data, dict):
            for key, value in data.items():
                # Handle nested data
                if isinstance(value, dict) and len(value) > 0:
                    print(f"  {key}:")
                    for subkey, subvalue in value.items():
                        print(f"    {subkey}: {subvalue}")
                else:
                    print(f"  {key}: {value}")
        else:
            print(f"  {data}")
        print("-" * 80)
    except Exception as e:
        logger.error(f"Error processing event: {e}")
        logger.error(f"Raw event data: {event_data}")
async def test_event_generator(ws):
    """Generate test events periodically"""
    if not args.test_events:
        return
    event_types = ["PAGE", "DOM", "CONSOLE", "NETWORK"]
    event_names = {
        "PAGE": ["page.load", "page.navigate", "page.error"],
        "DOM": ["dom.mutation", "dom.attribute", "dom.child"],
        "CONSOLE": ["console.log", "console.error", "console.warning"],
        "NETWORK": ["network.request", "network.response", "network.error"]
    }
    logger.info("Starting test event generator")
    while True:
        # Cycle through event types
        for event_type in event_types:
            # Cycle through event names for this type
            for event_name in event_names.get(event_type, ["test.event"]):
                try:
                    await generate_test_event(ws, event_type, event_name)
                    await asyncio.sleep(2)  # Wait between events
                except Exception as e:
                    logger.error(f"Error generating test event: {e}")
                    return
async def timeout_handler():
    """Handle timeout and exit gracefully"""
    if args.timeout > 0:
        logger.info(f"Will exit after {args.timeout} seconds")
        await asyncio.sleep(args.timeout)
        logger.info("Timeout reached, exiting")
        print(f"\nTest completed after {args.timeout} seconds")
        sys.exit(0)
async def main():
    """Main function"""
    try:
        logger.info(f"Connecting to WebSocket at {args.url}")
        # Start timeout handler if specified
        if args.timeout > 0:
            asyncio.create_task(timeout_handler())
        async with websockets.connect(args.url) as ws:
            logger.info("Connected to WebSocket server")
            # Receive welcome message
            welcome = await ws.recv()
            logger.info(f"Welcome message: {welcome}")
            # Subscribe to events
            subscription = await subscribe_to_events(ws, args.types)
            subscription_id = subscription.get("subscription_id", "unknown")
            logger.info(f"Subscribed to events with ID: {subscription_id}")
            # Start test event generator if requested
            if args.test_events:
                asyncio.create_task(test_event_generator(ws))
            # Print initial message
            print("\n" + "=" * 80)
            print("WebSocket Event Subscription Test Client")
            print(f"Connected to: {args.url}")
            print(f"Subscribed to event types: {args.types}")
            if args.test_events:
                print("Test event generation: Enabled")
            if args.timeout > 0:
                print(f"Will exit after {args.timeout} seconds")
            print("=" * 80 + "\n")
            # Receive events
            while True:
                message = await ws.recv()
                await print_event(message)
    except websockets.exceptions.ConnectionClosed:
        logger.error("WebSocket connection closed")
    except Exception as e:
        logger.error(f"Error: {e}")
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nScript terminated by user")
        sys.exit(0)
</file>

<file path="src/test_websocket.py">
#!/usr/bin/env python3
"""
Simple WebSocket server for testing event subscriptions.
This demonstrates the WebSocket event subscriptions feature with a minimal implementation.
"""
import asyncio
import json
import logging
import uuid
import time
from datetime import datetime
from typing import Dict, List, Set, Any, Optional, AsyncGenerator
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from enum import Enum
from contextlib import asynccontextmanager
# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)
# Define event types and models
class EventType(str, Enum):
    """Types of browser events"""
    PAGE = "PAGE"
    DOM = "DOM"
    CONSOLE = "CONSOLE"
    NETWORK = "NETWORK"
# Global variables
active_connections: Set[WebSocket] = set()
event_connections: Dict[str, WebSocket] = {}
active_subscriptions: Dict[str, Dict[str, Any]] = {}
subscription_handlers: Dict[str, List[str]] = {
    "PAGE": [],
    "DOM": [],
    "CONSOLE": [],
    "NETWORK": [],
}
# Forward declare the event generator function signature
async def event_generator():
    """Generate simulated events for testing"""
    pass  # Actual implementation below
# Define lifespan context manager
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Lifespan context manager for startup and shutdown events"""
    # Startup: Create task for event generator
    event_task = asyncio.create_task(event_generator())
    logger.info("WebSocket Event Test Server started")
    yield  # Run the application
    # Shutdown: Cancel the event generator task
    event_task.cancel()
    try:
        await event_task
    except asyncio.CancelledError:
        logger.info("Event generator task cancelled")
# Create FastAPI app with lifespan
app = FastAPI(
    title="WebSocket Event Test",
    lifespan=lifespan
)
# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Event handler functions
async def broadcast_event(event_type: str, event_name: str, data: Dict[str, Any]):
    """Broadcast an event to all subscribed clients"""
    event = {
        "type": event_type,
        "event": event_name,
        "timestamp": time.time(),
        "data": data
    }
    # Convert event to JSON string
    event_json = json.dumps(event)
    # Find subscriptions for this event type
    for subscription_id in subscription_handlers.get(event_type, []):
        if subscription_id in active_subscriptions:
            client_id = active_subscriptions[subscription_id]["client_id"]
            # Check if client is still connected
            if client_id in event_connections:
                try:
                    await event_connections[client_id].send_text(event_json)
                    logger.info(f"Event {event_name} sent to client {client_id}")
                except Exception as e:
                    logger.error(f"Error sending event to client {client_id}: {e}")
async def add_subscription(client_id: str, subscription_id: str, event_types: List[str], filters: Optional[Dict[str, Any]] = None):
    """Add a new subscription for a client"""
    # Store subscription details
    active_subscriptions[subscription_id] = {
        "client_id": client_id,
        "event_types": event_types,
        "filters": filters,
        "created_at": time.time()
    }
    # Register subscription for each event type
    for event_type in event_types:
        if event_type in subscription_handlers:
            subscription_handlers[event_type].append(subscription_id)
    logger.info(f"Added subscription {subscription_id} for client {client_id}, event types: {event_types}")
async def remove_subscription(subscription_id: str):
    """Remove a subscription"""
    if subscription_id in active_subscriptions:
        # Get event types for this subscription
        event_types = active_subscriptions[subscription_id].get("event_types", [])
        # Remove from subscription handlers
        for event_type in event_types:
            if event_type in subscription_handlers and subscription_id in subscription_handlers[event_type]:
                subscription_handlers[event_type].remove(subscription_id)
        # Remove from active subscriptions
        del active_subscriptions[subscription_id]
        logger.info(f"Removed subscription {subscription_id}")
        return True
    return False
# Actual implementation of event generator task
async def event_generator():
    """Generate simulated events for testing"""
    event_types = ["PAGE", "DOM", "CONSOLE", "NETWORK"]
    event_names = {
        "PAGE": ["page.load", "page.navigate", "page.error"],
        "DOM": ["dom.mutation", "dom.attribute", "dom.child"],
        "CONSOLE": ["console.log", "console.error", "console.warning"],
        "NETWORK": ["network.request", "network.response", "network.error"]
    }
    while True:
        # Only generate events if there are active subscriptions
        if active_subscriptions:
            # Select random event type
            event_type = event_types[int(time.time() * 10) % len(event_types)]
            # Check if there are any subscribers for this event type
            if subscription_handlers.get(event_type, []):
                # Select random event name
                names = event_names.get(event_type, ["test.event"])
                event_name = names[int(time.time() * 100) % len(names)]
                # Generate event data
                data = {
                    "timestamp": datetime.now().strftime("%H:%M:%S"),
                    "message": f"Simulated {event_type}.{event_name} event",
                    "value": round(time.time() % 100, 2),
                    "details": {
                        "random": uuid.uuid4().hex[:8],
                        "counter": int(time.time()) % 1000
                    }
                }
                # Broadcast event
                await broadcast_event(event_type, event_name, data)
                logger.debug(f"Generated event: {event_type}.{event_name}")
        # Wait before generating next event
        await asyncio.sleep(2)
# API endpoints
@app.get("/api/status")
async def get_status():
    """Get server status"""
    return {
        "status": "ok",
        "version": "0.1.0",
        "timestamp": time.time(),
        "connections": len(active_connections),
        "subscriptions": len(active_subscriptions)
    }
# WebSocket endpoint for browser events
@app.websocket("/ws/events")
async def websocket_browser_events(websocket: WebSocket):
    """WebSocket endpoint for browser events"""
    await websocket.accept()
    # Generate a unique client ID
    client_id = f"client_{str(uuid.uuid4())}"
    # Add to active connections
    active_connections.add(websocket)
    event_connections[client_id] = websocket
    # Send welcome message
    await websocket.send_text(json.dumps({
        "type": "connection",
        "client_id": client_id,
        "message": "Connected to WebSocket Event Test Server",
        "timestamp": time.time()
    }))
    logger.info(f"Client {client_id} connected")
    try:
        # Process incoming messages
        while True:
            # Receive message
            data = await websocket.receive_text()
            try:
                # Parse JSON message
                message = json.loads(data)
                action = message.get("action", "")
                # Process action
                if action == "subscribe":
                    # Subscribe to events
                    event_types = message.get("event_types", [])
                    filters = message.get("filters")
                    # Generate subscription ID
                    subscription_id = f"sub_{str(uuid.uuid4())}"
                    # Add subscription
                    await add_subscription(client_id, subscription_id, event_types, filters)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "subscription",
                        "subscription_id": subscription_id,
                        "event_types": event_types,
                        "filters": filters,
                        "timestamp": time.time()
                    }))
                elif action == "unsubscribe":
                    # Unsubscribe from events
                    subscription_id = message.get("subscription_id", "")
                    # Remove subscription
                    success = await remove_subscription(subscription_id)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "unsubscription",
                        "subscription_id": subscription_id,
                        "success": success,
                        "timestamp": time.time()
                    }))
                elif action == "list":
                    # List active subscriptions for this client
                    client_subscriptions = {
                        sub_id: sub_data
                        for sub_id, sub_data in active_subscriptions.items()
                        if sub_data.get("client_id") == client_id
                    }
                    # Send subscription list
                    await websocket.send_text(json.dumps({
                        "type": "subscription_list",
                        "subscriptions": client_subscriptions,
                        "timestamp": time.time()
                    }))
                elif action == "test_event":
                    # Generate a test event for debugging
                    event_type = message.get("event_type", "PAGE")
                    event_name = message.get("event_name", "test.event")
                    event_data = message.get("data", {"message": "Test event"})
                    # Broadcast event
                    await broadcast_event(event_type, event_name, event_data)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "event_generated",
                        "event_type": event_type,
                        "event_name": event_name,
                        "timestamp": time.time()
                    }))
                else:
                    # Unknown action
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "error": f"Unknown action: {action}",
                        "timestamp": time.time()
                    }))
            except json.JSONDecodeError:
                # Invalid JSON
                await websocket.send_text(json.dumps({
                    "type": "error",
                    "error": "Invalid JSON message",
                    "timestamp": time.time()
                }))
    except WebSocketDisconnect:
        # Client disconnected
        logger.info(f"Client {client_id} disconnected")
        # Remove from active connections
        active_connections.discard(websocket)
        if client_id in event_connections:
            del event_connections[client_id]
        # Remove client subscriptions
        client_subscriptions = [
            sub_id for sub_id, sub_data in active_subscriptions.items()
            if sub_data.get("client_id") == client_id
        ]
        for subscription_id in client_subscriptions:
            await remove_subscription(subscription_id)
# New endpoint for browser events at the expected path
@app.websocket("/ws/browser/events")
async def websocket_browser_events_alias(websocket: WebSocket):
    """WebSocket endpoint for browser events (alias for compatibility)"""
    await websocket.accept()
    # Generate a unique client ID
    client_id = f"client_{str(uuid.uuid4())}"
    # Add to active connections
    active_connections.add(websocket)
    event_connections[client_id] = websocket
    # Send welcome message
    await websocket.send_text(json.dumps({
        "type": "connection",
        "client_id": client_id,
        "message": "Connected to MCP Browser Event Subscription Service",
        "timestamp": time.time()
    }))
    logger.info(f"Client {client_id} connected to browser events endpoint")
    try:
        # Process incoming messages
        while True:
            # Receive message
            data = await websocket.receive_text()
            try:
                # Parse JSON message
                message = json.loads(data)
                action = message.get("action", "")
                # Process action
                if action == "subscribe":
                    # Subscribe to events
                    event_types = message.get("event_types", [])
                    filters = message.get("filters")
                    # Generate subscription ID
                    subscription_id = f"sub_{str(uuid.uuid4())}"
                    # Add subscription
                    await add_subscription(client_id, subscription_id, event_types, filters)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "subscription",
                        "subscription_id": subscription_id,
                        "event_types": event_types,
                        "filters": filters,
                        "timestamp": time.time()
                    }))
                elif action == "unsubscribe":
                    # Unsubscribe from events
                    subscription_id = message.get("subscription_id", "")
                    # Remove subscription
                    success = await remove_subscription(subscription_id)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "unsubscription",
                        "subscription_id": subscription_id,
                        "success": success,
                        "timestamp": time.time()
                    }))
                elif action == "list":
                    # List active subscriptions for this client
                    client_subscriptions = {
                        sub_id: sub_data
                        for sub_id, sub_data in active_subscriptions.items()
                        if sub_data.get("client_id") == client_id
                    }
                    # Send subscription list
                    await websocket.send_text(json.dumps({
                        "type": "subscription_list",
                        "subscriptions": client_subscriptions,
                        "timestamp": time.time()
                    }))
                elif action == "execute":
                    # Handle execute command (for navigation, etc.)
                    command = message.get("command", "")
                    params = message.get("params", {})
                    # Log the command (in a real implementation, this would actually execute it)
                    logger.info(f"Received execute command: {command} with params: {params}")
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "command_executed",
                        "command": command,
                        "success": True,
                        "message": f"Command {command} acknowledged (simulation)",
                        "timestamp": time.time()
                    }))
                    # If this is a navigation command, generate a simulated PAGE event
                    if command == "navigate" and "url" in params:
                        # Simulate a page load event
                        await asyncio.sleep(0.5)  # Simulate loading time
                        page_event_data = {
                            "url": params["url"],
                            "title": f"Page Title for {params['url']}",
                            "status": 200,
                            "timestamp": time.time()
                        }
                        # Broadcast a PAGE event
                        await broadcast_event("PAGE", "page.load", page_event_data)
                elif action == "test_event":
                    # Generate a test event for debugging
                    event_type = message.get("event_type", "PAGE")
                    event_name = message.get("event_name", "test.event")
                    event_data = message.get("data", {"message": "Test event"})
                    # Broadcast event
                    await broadcast_event(event_type, event_name, event_data)
                    # Send confirmation
                    await websocket.send_text(json.dumps({
                        "type": "event_generated",
                        "event_type": event_type,
                        "event_name": event_name,
                        "timestamp": time.time()
                    }))
                else:
                    # Unknown action
                    await websocket.send_text(json.dumps({
                        "type": "error",
                        "error": f"Unknown action: {action}",
                        "timestamp": time.time()
                    }))
            except json.JSONDecodeError:
                # Invalid JSON
                await websocket.send_text(json.dumps({
                    "type": "error",
                    "error": "Invalid JSON message",
                    "timestamp": time.time()
                }))
    except WebSocketDisconnect:
        # Client disconnected
        logger.info(f"Client {client_id} disconnected")
        # Remove from active connections
        active_connections.discard(websocket)
        if client_id in event_connections:
            del event_connections[client_id]
        # Remove client subscriptions
        client_subscriptions = [
            sub_id for sub_id, sub_data in active_subscriptions.items()
            if sub_data.get("client_id") == client_id
        ]
        for subscription_id in client_subscriptions:
            await remove_subscription(subscription_id)
# Main entry point
if __name__ == "__main__":
    # Use reload=False to prevent frequent reloads during development
    uvicorn.run("test_websocket:app", host="0.0.0.0", port=8765, reload=False)
</file>

<file path=".dockerignore">
# Version control
.git
.gitignore
.github

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Python Virtual Environments
.env
.venv
env/
venv/
ENV/

# Playwright
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/
ms-playwright/

# Development and testing
tests/
.coverage
htmlcov/
.pytest_cache/
.tox/
.nox/
.hypothesis/
.coverage.*
coverage.xml
*.cover

# IDE & editor files
.idea/
.vscode/
*.swp
*.swo
*~
.DS_Store
.project
.pydevproject
.settings
.ropeproject
.spyderproject
.spyproject

# Docker
.dockerignore
docker-compose.override.yml
docker-compose.*.yml
!docker-compose.yml
.docker/data/

# uv
.uv/

# Temp files
tmp/
temp/

# Documentation
docs/
README.md
LICENSE
CHANGELOG.md
CONTRIBUTING.md

# Local configuration files
*.local
local_config.yaml
local_settings.py

# Log files
*.log
logs/

# Large binary files
*.db
*.sqlite3
*.dump

# Other
.eslintrc
.jshintrc
.editorconfig
.env*
!.env.example
**/*.md
!README.md
</file>

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg

# Virtual environment
venv/
.venv/
ENV/

# IDE files
.idea/
.vscode/
*.swp
*.swo

# OS specific
.DS_Store
Thumbs.db

# Logs
*.log

# Environment variables
.env

# Output files from API endpoints
output/
*.png
*.jpg
*.jpeg
*.json

# Playwright
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/

# Logging & Debugging
*.log
logs/
.coverage
htmlcov/
.pytest_cache/
.tox/
.nox/
.hypothesis/
.coverage.*
nosetests.xml
coverage.xml
*.cover
.hypothesis/

# IDE & editor files
.idea/
.vscode/
*.swp
*.swo
*~
.DS_Store
.project
.pydevproject
.settings/
.ropeproject
.spyderproject
.spyproject

# Environment variables
.env
.env.*
!.env.example

# Docker
.docker/data/

# uv
.uv/

# Temp files
tmp/
temp/

# Local configurations
*.local
local_config.yaml
local_settings.py

# MCP Browser specific
ms-playwright/
*.db
*.sqlite3
</file>

<file path=".python-version">
3.13
</file>

<file path="CHANGELOG.md">
# Changelog

## [0.2.0] - 2025-03-23

### Added
- Implemented Accessibility Testing API
  - Added `/api/accessibility/test` endpoint that analyzes web pages for accessibility issues
  - Support for multiple standards (WCAG 2.0 A/AA/AAA, WCAG 2.1 AA, Section 508)
  - Integration with axe-core for comprehensive accessibility testing
  - Element-specific testing with selectors
  - Detailed violation, warning, and incomplete results
  - HTML context inclusion for better debugging

- Implemented Responsive Design Testing API
  - Added `/api/responsive/test` endpoint that tests web pages across different viewport sizes
  - Support for multiple viewport testing (mobile, tablet, laptop, desktop)
  - Element comparison across viewport sizes to detect responsive layout issues
  - Media query analysis to identify breakpoints
  - Touch target size validation for mobile-friendly testing
  - Screenshots captured at each viewport size for visual comparison
  - Detailed metrics and responsive issue reporting

- Added API documentation in `docs/api.md`
- Created example scripts in `docs/examples/`
- Added GitHub PR template

### Fixed
- JavaScript boolean values in Playwright page.evaluate() functions
- Fixed proper output directory structure for API test results
- Improved error handling in API endpoints

## [0.1.0] - 2025-03-22

### Added
- Implemented core browser automation infrastructure
- Created Screenshot Capture API
  - Added `/api/screenshots/capture` endpoint with configurable options
  - Support for different viewport sizes
  - Full page and viewport-only screenshots
  - Multiple image formats (PNG/JPEG) and quality options

- Implemented DOM Extraction API
  - Added `/api/dom/extract` endpoint for DOM structure analysis
  - Support for CSS selector targeting
  - Optional style computation and attribute extraction

- Implemented CSS Analysis API
  - Added `/api/css/analyze` endpoint for CSS property analysis
  - Detailed style property extraction
  - Optional accessibility checking
  - Element visibility and positioning information

- Created testing framework with automated test scripts
- Set up Docker containerization with Playwright and Xvfb
- Established WebSocket interface for real-time communication
- Created comprehensive documentation in Memory Bank
</file>

<file path="docker-compose.yml">
services:
  mcp-browser:
    build: .
    image: neoforge-dev/mcp-browser:latest
    environment:
      - MCP_SECRET=${MCP_SECRET}
      - SERVER_PORT=8000
      - DISPLAY=:99
    security_opt:
      - apparmor=mcp-browser
    deploy:
      resources:
        limits:
          cpus: "1.5"
          memory: 2G
    ports:
      - "7665:8000"
    volumes:
      - ./src:/app/src
      - /tmp/.X11-unix:/tmp/.X11-unix
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
</file>

<file path="Dockerfile">
FROM mcr.microsoft.com/playwright:v1.51.1-noble

# Security setup
RUN apt-get update && \
    apt-get install -y xvfb curl python3 python3-pip && \
    mkdir -p /home/pwuser/Downloads && \
    chown -R pwuser:pwuser /home/pwuser

# Set up the application directory
WORKDIR /app

# Copy pyproject.toml first for dependency installation
COPY pyproject.toml .

# Install dependencies using pip with system package override
RUN python3 -m pip install --break-system-packages -e .

# Install Playwright browsers
RUN python3 -m playwright install chromium

# Copy security configurations
COPY docker/apparmor/mcp-browser.profile /etc/apparmor.d/
RUN apparmor_parser -r /etc/apparmor.d/mcp-browser.profile || echo "AppArmor profile loading failed - skipping"

# Copy application files
COPY src/ /app/src/
COPY docker/xvfb-init.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/xvfb-init.sh

# Change ownership of the application to the non-root user
RUN chown -R pwuser:pwuser /app

# Switch to non-root user
USER pwuser
EXPOSE 7665

CMD ["/usr/local/bin/xvfb-init.sh"]
</file>

<file path="example_mac_mini_setup.md">
# Setting up an MCP Browser on Mac Mini

This guide demonstrates how to set up the MCP Browser on a Mac Mini with a single command, allowing Claude or other MCP clients to visualize and test web frontends.

## Quick Start (One-Line Installation)

Simply run this command in your terminal on the Mac Mini:

```bash
curl -sSL https://raw.githubusercontent.com/neoforge-dev/mcp-browser/main/install_one_line.sh | bash
```

## What Gets Installed

The one-line installer will:

1. Install required dependencies (Git, Docker, Python, XQuartz)
2. Clone the MCP Browser repository
3. Configure environment settings
4. Start the MCP Browser server in Docker
5. Create a browser test client for visualization

## Testing the Installation

After installation completes, you'll see connection details displayed:

```
========================================
      MCP Browser Installation Complete
========================================

Server URL: http://192.168.1.x:7665
API Status: http://192.168.1.x:7665/api/status
WebSocket:  ws://192.168.1.x:7665/ws
Event WS:   ws://192.168.1.x:7665/ws/browser/events

Test Client: file:///Users/username/.mcp-browser/client/index.html

Connection Details:
MCP Secret: abcd1234efgh5678...

Connect your MCP client to this Mac using:
IP: 192.168.1.x
Port: 7665
Secret: abcd1234efgh5678...
```

## Connecting Claude or Other MCP Clients

You can connect Claude or other MCP clients to the server using the displayed IP, port, and secret. The server provides:

1. RESTful API for browser control
2. WebSocket API for real-time events
3. Visual browser interface for testing

## For iOS Development

To develop an iOS app as an MCP client:

1. Connect to the WebSocket endpoint: `ws://mac-ip:7665/ws/browser/events`
2. Subscribe to browser events using the WebSocket protocol
3. Use the REST API endpoints to control the browser

## Troubleshooting

If you encounter issues:

1. Check the installation log: `~/mcp-browser-install.log`
2. Verify Docker is running: `docker ps`
3. Check server logs: `cd ~/mcp-browser && docker-compose logs`
4. Restart the server: `cd ~/mcp-browser && docker-compose restart`
</file>

<file path="install_one_line.sh">
#!/bin/bash
#
# MCP Browser One-Line Installer Launcher
# Usage: curl -sSL https://raw.githubusercontent.com/neoforge-dev/mcp-browser/main/install_one_line.sh | bash
set -e
# Configuration variables
REPO="neoforge-dev/mcp-browser"
BRANCH="main"
INSTALLER_FILE="install.sh"
GITHUB_RAW_URL="https://raw.githubusercontent.com/${REPO}/${BRANCH}/${INSTALLER_FILE}"
# Check if running on Mac
if [[ "$(uname)" != "Darwin" ]]; then
  echo "This installer is designed for macOS. Please run it on a Mac."
  exit 1
fi
# Show banner
echo "========================================"
echo "      MCP Browser One-Line Installer"
echo "========================================"
echo ""
echo "This will install MCP Browser on your Mac"
echo "with visualization support for AI agents."
echo ""
# Ask for confirmation
read -p "Continue with installation? (y/n) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "Installation cancelled."
  exit 0
fi
# Install Homebrew if not present
if ! command -v brew &> /dev/null; then
  echo "Installing Homebrew..."
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
fi
# Download and run the installer with line ending fixes
echo "Downloading and running MCP Browser installer..."
curl -sSL "$GITHUB_RAW_URL" | tr -d '\r' > /tmp/install_mcp_browser.sh
chmod +x /tmp/install_mcp_browser.sh
# Run the installer
/tmp/install_mcp_browser.sh
# Clean up
rm /tmp/install_mcp_browser.sh
</file>

<file path="install.sh">
#!/bin/bash
#
# MCP Browser Installer
# This script installs and configures MCP Browser for visual testing on Mac
set -e
# Configuration variables
REPO_URL="https://github.com/neoforge-dev/mcp-browser.git"
INSTALL_DIR="$HOME/mcp-browser"
PORT=7665
SECRET=$(openssl rand -hex 16)
LOG_FILE="$HOME/mcp-browser-install.log"
# Show banner
echo "========================================"
echo "      MCP Browser Installer"
echo "========================================"
echo ""
echo "This will install MCP Browser on your Mac"
echo "with visualization support for AI agents."
echo ""
# Ask for confirmation
read -p "Continue with installation? (y/n) " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "Installation cancelled."
  exit 0
fi
# Function to check for prerequisites
check_prerequisites() {
  echo "Checking prerequisites..."
  # Check for Git
  if ! command -v git &> /dev/null; then
    echo "Git not found. Installing..."
    brew install git
  fi
  # Check for Docker
  if ! command -v docker &> /dev/null; then
    echo "Docker not found. Installing..."
    brew install docker
    brew install docker-compose
  fi
  # Check for Python
  if ! command -v python3 &> /dev/null; then
    echo "Python not found. Installing..."
    brew install python
  fi
  # Check for XQuartz (X11 for Mac)
  if ! command -v xquartz &> /dev/null; then
    echo "XQuartz not found. Installing..."
    brew install --cask xquartz
  fi
}
# Function to clone or update repository
setup_repository() {
  echo "Setting up repository..."
  if [ -d "$INSTALL_DIR" ]; then
    echo "Repository exists. Updating..."
    cd "$INSTALL_DIR"
    git pull
  else
    echo "Cloning repository..."
    git clone "$REPO_URL" "$INSTALL_DIR"
    cd "$INSTALL_DIR"
  fi
}
# Function to configure environment
configure_environment() {
  echo "Configuring environment..."
  # Create .env file
  cat > "$INSTALL_DIR/.env" << EOF
MCP_SECRET=$SECRET
SERVER_PORT=8000
EOF
  # Create browser display configuration
  echo "Configuring browser display..."
  mkdir -p "$HOME/.mcp-browser"
  cat > "$HOME/.mcp-browser/config.json" << EOF
{
  "display": {
    "width": 1280,
    "height": 800,
    "deviceScaleFactor": 2,
    "mobile": false
  },
  "server": {
    "port": $PORT,
    "secret": "$SECRET"
  },
  "browser": {
    "headless": false,
    "defaultViewport": null
  }
}
EOF
}
# Function to start services
start_services() {
  echo "Starting services..."
  # Start XQuartz if not running
  if ! pgrep -x "Xquartz" > /dev/null && ! pgrep -x "X11" > /dev/null; then
    echo "Starting XQuartz X11 server..."
    # Try running the binary directly
    if [ -f "/Applications/Utilities/XQuartz.app/Contents/MacOS/X11" ]; then
      echo "Using XQuartz binary directly..."
      /Applications/Utilities/XQuartz.app/Contents/MacOS/X11 &
      sleep 5
    elif [ -f "/opt/X11/bin/Xquartz" ]; then
      echo "Using Xquartz binary from /opt/X11/bin..."
      /opt/X11/bin/Xquartz &
      sleep 5
    else
      echo "Trying to open XQuartz application..."
      open "/Applications/Utilities/XQuartz.app"
      sleep 5
      # Check if XQuartz started successfully
      if ! pgrep -x "Xquartz" > /dev/null && ! pgrep -x "X11" > /dev/null; then
        echo "WARNING: Could not start XQuartz automatically."
        echo "You may need to start it manually before proceeding."
        echo "Try running: /Applications/Utilities/XQuartz.app/Contents/MacOS/X11"
        echo "Or open XQuartz from your Applications folder."
        read -p "Press Enter to continue once XQuartz is running, or Ctrl+C to abort..."
      fi
    fi
  else
    echo "XQuartz is already running."
  fi
  # Start MCP Browser
  cd "$INSTALL_DIR"
  docker-compose down || true
  docker-compose up -d
  # Wait for service to be ready
  echo "Waiting for MCP Browser to be ready..."
  for i in {1..15}; do
    if curl -s "http://localhost:$PORT/api/status" | grep -q "ok"; then
      echo "MCP Browser is ready!"
      break
    fi
    if [ $i -eq 15 ]; then
      echo "MCP Browser failed to start. Check logs at: docker-compose logs"
      exit 1
    fi
    echo "Waiting... ($i/15)"
    sleep 5
  done
}
# Function to set up browser client
setup_browser_client() {
  echo "Setting up browser client..."
  # Create browser client HTML for testing
  mkdir -p "$HOME/.mcp-browser/client"
  cat > "$HOME/.mcp-browser/client/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCP Browser Client</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
    .container { max-width: 800px; margin: 0 auto; }
    .status { margin-bottom: 20px; padding: 10px; border-radius: 4px; }
    .connected { background-color: #d4edda; color: #155724; }
    .disconnected { background-color: #f8d7da; color: #721c24; }
    .event-log { height: 300px; overflow-y: auto; background-color: #f8f9fa; 
                 border: 1px solid #ddd; padding: 10px; border-radius: 4px; }
    button { background-color: #007bff; color: white; border: none; 
             padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px; }
    button:hover { background-color: #0069d9; }
    input { padding: 8px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>MCP Browser Client</h1>
    <div id="status" class="status disconnected">Disconnected</div>
    <div class="actions">
      <button id="connect">Connect</button>
      <button id="disconnect" disabled>Disconnect</button>
      <button id="subscribe" disabled>Subscribe to Events</button>
    </div>
    <h2>Browser Control</h2>
    <div class="browser-control">
      <input type="text" id="url" placeholder="https://example.com" value="https://example.com">
      <button id="navigate" disabled>Navigate</button>
      <button id="screenshot" disabled>Take Screenshot</button>
      <button id="back" disabled>Back</button>
      <button id="forward" disabled>Forward</button>
    </div>
    <h2>Event Log</h2>
    <div id="event-log" class="event-log"></div>
  </div>
  <script>
    // Get port from URL or use default
    const PORT = 7665;
    // DOM Elements
    const statusEl = document.getElementById('status');
    const eventLogEl = document.getElementById('event-log');
    const connectBtn = document.getElementById('connect');
    const disconnectBtn = document.getElementById('disconnect');
    const subscribeBtn = document.getElementById('subscribe');
    const navigateBtn = document.getElementById('navigate');
    const screenshotBtn = document.getElementById('screenshot');
    const backBtn = document.getElementById('back');
    const forwardBtn = document.getElementById('forward');
    const urlInput = document.getElementById('url');
    // WebSocket connection
    let socket = null;
    let eventSocket = null;
    // Log an event
    function logEvent(message, isError = false) {
      const item = document.createElement('div');
      item.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      if (isError) {
        item.style.color = '#dc3545';
      }
      eventLogEl.appendChild(item);
      eventLogEl.scrollTop = eventLogEl.scrollHeight;
    }
    // Connect to WebSocket
    connectBtn.addEventListener('click', () => {
      // Connect to main WebSocket
      socket = new WebSocket(`ws://localhost:${PORT}/ws`);
      socket.onopen = () => {
        statusEl.textContent = 'Connected';
        statusEl.classList.remove('disconnected');
        statusEl.classList.add('connected');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        subscribeBtn.disabled = false;
        navigateBtn.disabled = false;
        screenshotBtn.disabled = false;
        backBtn.disabled = false;
        forwardBtn.disabled = false;
        logEvent('Connected to WebSocket');
      };
      socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        logEvent(`Received: ${JSON.stringify(data)}`);
      };
      socket.onclose = () => {
        statusEl.textContent = 'Disconnected';
        statusEl.classList.remove('connected');
        statusEl.classList.add('disconnected');
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        subscribeBtn.disabled = true;
        navigateBtn.disabled = true;
        screenshotBtn.disabled = true;
        backBtn.disabled = true;
        forwardBtn.disabled = true;
        logEvent('Disconnected from WebSocket');
      };
      socket.onerror = (error) => {
        logEvent(`WebSocket Error: ${error}`, true);
      };
    });
    // Disconnect from WebSocket
    disconnectBtn.addEventListener('click', () => {
      if (socket) {
        socket.close();
      }
      if (eventSocket) {
        eventSocket.close();
      }
    });
    // Subscribe to events
    subscribeBtn.addEventListener('click', () => {
      // Connect to event WebSocket
      eventSocket = new WebSocket(`ws://localhost:${PORT}/ws/browser/events`);
      eventSocket.onopen = () => {
        logEvent('Connected to Event WebSocket');
        // Subscribe to all event types
        const subscribeMsg = {
          action: 'subscribe',
          event_types: ['PAGE', 'DOM', 'CONSOLE', 'NETWORK'],
          filters: { url_pattern: '*' }
        };
        eventSocket.send(JSON.stringify(subscribeMsg));
      };
      eventSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        logEvent(`Event: ${JSON.stringify(data)}`);
      };
      eventSocket.onclose = () => {
        logEvent('Disconnected from Event WebSocket');
      };
      eventSocket.onerror = (error) => {
        logEvent(`Event WebSocket Error: ${error}`, true);
      };
    });
    // Navigate to URL
    navigateBtn.addEventListener('click', () => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const url = urlInput.value;
        fetch(`http://localhost:${PORT}/api/browser/navigate`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ url, timeout: 30, wait_until: 'networkidle' }),
        })
        .then(response => response.json())
        .then(data => {
          logEvent(`Navigated to: ${url}`);
        })
        .catch((error) => {
          logEvent(`Navigation Error: ${error}`, true);
        });
      }
    });
    // Take screenshot
    screenshotBtn.addEventListener('click', () => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        fetch(`http://localhost:${PORT}/api/browser/screenshot`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ full_page: true }),
        })
        .then(response => response.json())
        .then(data => {
          if (data.image_data) {
            const img = document.createElement('img');
            img.src = `data:image/png;base64,${data.image_data}`;
            img.style.maxWidth = '100%';
            img.style.marginTop = '10px';
            const wrapper = document.createElement('div');
            wrapper.appendChild(img);
            eventLogEl.appendChild(wrapper);
            eventLogEl.scrollTop = eventLogEl.scrollHeight;
            logEvent('Screenshot taken');
          }
        })
        .catch((error) => {
          logEvent(`Screenshot Error: ${error}`, true);
        });
      }
    });
    // Go back
    backBtn.addEventListener('click', () => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        fetch(`http://localhost:${PORT}/api/browser/back`, {
          method: 'POST',
        })
        .then(response => response.json())
        .then(data => {
          logEvent('Navigated back');
        })
        .catch((error) => {
          logEvent(`Back Error: ${error}`, true);
        });
      }
    });
    // Go forward
    forwardBtn.addEventListener('click', () => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        fetch(`http://localhost:${PORT}/api/browser/forward`, {
          method: 'POST',
        })
        .then(response => response.json())
        .then(data => {
          logEvent('Navigated forward');
        })
        .catch((error) => {
          logEvent(`Forward Error: ${error}`, true);
        });
      }
    });
  </script>
</body>
</html>
EOF
  echo "Browser client is available at: file://$HOME/.mcp-browser/client/index.html"
}
# Function to display installation summary
show_summary() {
  IP_ADDRESS=$(ipconfig getifaddr en0 || echo "localhost")
  echo ""
  echo "========================================"
  echo "      MCP Browser Installation Complete"
  echo "========================================"
  echo ""
  echo "Server URL: http://$IP_ADDRESS:$PORT"
  echo "API Status: http://$IP_ADDRESS:$PORT/api/status"
  echo "WebSocket:  ws://$IP_ADDRESS:$PORT/ws"
  echo "Event WS:   ws://$IP_ADDRESS:$PORT/ws/browser/events"
  echo ""
  echo "Test Client: file://$HOME/.mcp-browser/client/index.html"
  echo ""
  echo "Connection Details:"
  echo "MCP Secret: $SECRET"
  echo ""
  echo "Installation Log: $LOG_FILE"
  echo ""
  echo "Connect your MCP client to this Mac using:"
  echo "IP: $IP_ADDRESS"
  echo "Port: $PORT"
  echo "Secret: $SECRET"
  echo ""
  echo "To stop the server: cd $INSTALL_DIR && docker-compose down"
  echo "To start the server: cd $INSTALL_DIR && docker-compose up -d"
  echo ""
  echo "========================================"
}
# Main installation function
main() {
  check_prerequisites
  setup_repository
  configure_environment
  start_services
  setup_browser_client
  show_summary
  echo "MCP Browser installation completed successfully!"
}
# Execute main function and log output
{
  main
} 2>&1 | tee -a "$LOG_FILE"
</file>

<file path="Makefile">
build:
	docker-compose build

run:
	docker-compose up -d

test:
	docker-compose exec mcp-browser pytest tests/ -v

publish:
	docker login -u ${DOCKER_USER} -p ${DOCKER_PASS}
	docker tag mcp-browser neoforge-dev/mcp-browser:$(shell git rev-parse --short HEAD)
	docker push neoforge-dev/mcp-browser

generate-secret:
	@echo "MCP_SECRET=$(shell openssl rand -hex 32)" > .env

security-check:
	docker run --rm -it \
	  --security-opt apparmor=mcp-browser \
	  --entrypoint=lynis \
	  neoforge-dev/mcp-browser:latest audit system
</file>

<file path="ONE_LINE_INSTALL.md">
# MCP Browser One-Line Installation

## Mac Setup

To set up MCP Browser on your Mac with browser visualization for AI agents, run this command:

```bash
curl -sSL https://raw.githubusercontent.com/neoforge-dev/mcp-browser/main/install_one_line.sh | bash
```

## What This Does

This command:

1. Installs all required dependencies (including Homebrew if needed)
2. Sets up Docker and other prerequisites 
3. Configures MCP Browser with visualization support
4. Creates a browser test client for viewing and controlling the browser
5. Sets up WebSocket communication for real-time browser events
6. Provides configuration details for connecting your MCP client

## Requirements

- Mac running macOS
- Internet connection
- Administrator access

## Troubleshooting XQuartz Issues

If you encounter issues with XQuartz not starting properly during installation:

1. The installer will attempt to start XQuartz in several ways:
   - First by checking if it's already running
   - Then by trying to start it directly using the binary
   - Finally by opening the application

2. If automatic startup fails, you'll be prompted to start XQuartz manually:
   - Try running: `/Applications/Utilities/XQuartz.app/Contents/MacOS/X11`
   - Or open XQuartz from your Applications folder

3. Once XQuartz is running, press Enter to continue with the installation

## For iOS Development

For iOS app development as an MCP client:

1. Use the provided server URL, WebSocket endpoints, and secret generated during installation.
2. Implement WebSocket communication in your iOS app to connect to the MCP Browser server.
3. Utilize the API endpoints for browser control and event subscription.

## Manual Setup

If you prefer manual setup, you can:

1. Clone the repository: `git clone https://github.com/neoforge-dev/mcp-browser.git`
2. Navigate to the directory: `cd mcp-browser`
3. Run the installer: `./install.sh`

## Viewing and Testing

After installation, you can access:

- Test Client: `file:///Users/[username]/.mcp-browser/client/index.html`
- Server Status: `http://[mac-ip]:7665/api/status`

## Troubleshooting

If you encounter issues:

1. Check the installation log at `~/mcp-browser-install.log`
2. Ensure Docker is running properly
3. Check the Docker container logs: `cd ~/mcp-browser && docker-compose logs`
</file>

<file path="pyproject.toml">
[project]
name = "mcp-browser"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "aiofiles>=24.1.0",
    "aiohttp>=3.11.14",
    "bcrypt>=4.3.0",
    "fastapi>=0.108.0",
    "httpx>=0.28.1",
    "mcp[cli]>=1.5.0",
    "passlib>=1.7.4",
    "playwright>=1.51.0",
    "python-jose>=3.4.0",
    "python-multipart>=0.0.20",
    "pyyaml>=6.0",
    "requests>=2.32.3",
    "uvicorn[standard]>=0.24.0",
    "websockets>=15.0.1",
]
</file>

<file path="README.md">
# MCP Browser

A headless browser interface for the Model Control Protocol (MCP).

## Features

- Headless browser automation using Playwright
- Web UI for browser interaction
- WebSocket communication for real-time updates
- Real-time browser event subscription system
- Integration with MCP for AI agents

## Prerequisites

- Python 3.13+
- [uv](https://github.com/astral-sh/uv) for dependency management
- Docker (for containerized usage)

## Installation

### One-Line Installation

To install MCP Browser on your Mac with one command:

```bash
curl -sSL https://raw.githubusercontent.com/neoforge-dev/mcp-browser/main/install_one_line.sh | bash
```

This command will download and run the installer with proper line ending handling to avoid common issues.

### Manual Installation

For manual installation:

1. Clone this repository
2. Run the installer script:

```bash
git clone https://github.com/neoforge-dev/mcp-browser.git
cd mcp-browser
./install.sh
```

### XQuartz Requirements

MCP Browser requires XQuartz (X11) for proper visualization. The installer will:

1. Check if XQuartz is already installed and install it if needed
2. Attempt to start the X11 server in various ways
3. Prompt you to start it manually if automatic methods fail

If you encounter issues, see the [Troubleshooting XQuartz Issues](ONE_LINE_INSTALL.md#troubleshooting-xquartz-issues) section.

## Local Development

### Setup with uv

```bash
# Clone the repository
git clone https://github.com/yourusername/mcp-browser.git
cd mcp-browser

# Install dependencies
uv venv .venv
source .venv/bin/activate
uv pip install -e .

# Install Playwright browsers
python -m playwright install
```

### Running Locally

For a simple test without Xvfb:

```bash
./simple_test.sh
```

For a full test with Xvfb (requires X11):

```bash
./test_local.sh
```

## Docker Deployment

Build and run using Docker Compose:

```bash
# Set your MCP secret
export MCP_SECRET=your_secret_key

# Build and run
docker-compose up --build
```

Or use the provided script:

```bash
./run.sh
```

## Configuration

The following environment variables can be set:

- `MCP_SECRET`: Secret key for MCP authentication
- `SERVER_PORT`: Port to run the server on (default: 7665)
- `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD`: Set to 1 to skip browser download and run in headless-only mode

## API Endpoints

- `GET /`: Web UI
- `GET /api/status`: Get browser and MCP client status
- `WebSocket /ws`: WebSocket endpoint for real-time communication
- `WebSocket /ws/browser/events`: WebSocket endpoint for browser event subscriptions
- `GET /api/browser/subscribe`: Subscribe to browser events
- `GET /api/browser/unsubscribe`: Unsubscribe from browser events
- `GET /api/browser/subscriptions`: List active event subscriptions

## Event Subscriptions

The MCP Browser supports real-time event subscriptions via WebSockets. This allows clients to receive browser events as they happen, including:

- Page events (navigation, load, error)
- DOM events (mutations, changes)
- Console events (logs, warnings, errors)
- Network events (requests, responses, errors)

For detailed documentation and examples of the event subscription system, see:
- [WebSocket Events Documentation](./WEBSOCKET_EVENTS.md)
- [Event Subscription Example](./examples/event_subscription_example.py)

## License

MIT
</file>

<file path="run_analysis.sh">
#!/bin/bash
# Run the MCP Browser with all frontend analysis APIs enabled
# Default port
PORT=7665
# Banner function
function print_banner() {
    echo "==============================================="
    echo "  MCP Browser - Frontend Analysis Platform"
    echo "  Version 0.2.0"
    echo "==============================================="
    echo ""
}
# Help function
function print_help() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -p, --port PORT    Specify the port to run on (default: 7665)"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Available API Endpoints:"
    echo "  - /api/screenshots/capture   Capture screenshots with various options"
    echo "  - /api/dom/extract           Extract and analyze DOM structure"
    echo "  - /api/css/analyze           Analyze CSS properties of elements"
    echo "  - /api/accessibility/test    Test for accessibility issues"
    echo "  - /api/responsive/test       Test responsive behavior across viewports"
    echo ""
    echo "Example: $0 --port 8080"
}
# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--port)
            PORT="$2"
            shift
            shift
            ;;
        -h|--help)
            print_banner
            print_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_help
            exit 1
            ;;
    esac
done
# Create required directories
mkdir -p output/screenshots
mkdir -p output/dom
mkdir -p output/css
mkdir -p output/accessibility
mkdir -p output/responsive
# Print banner
print_banner
# Check for Python and uv
if ! command -v python3 &> /dev/null; then
    echo "Error: Python 3 is required but not found"
    exit 1
fi
if ! command -v uv &> /dev/null; then
    echo "Error: The uv package manager is required but not found"
    echo "Install with: pip install uv"
    exit 1
fi
# Activate virtual environment if it exists
if [ -d ".venv" ]; then
    echo "Activating virtual environment..."
    source .venv/bin/activate
fi
# Set environment variables
export SERVER_PORT=$PORT
# Run the server
echo "Starting MCP Browser on port $PORT..."
echo "Press Ctrl+C to stop the server"
echo ""
uv run src/main.py
# Capture Ctrl+C and clean up
trap 'echo "Shutting down MCP Browser..."; exit 0' INT
</file>

<file path="run.sh">
#!/bin/bash
set -e
# Check if .env file exists and source it
if [ -f .env ]; then
    echo "Loading environment variables from .env file..."
    export $(grep -v '^#' .env | xargs)
elif [ -f .env.example ]; then
    echo "No .env file found. Using .env.example as a template..."
    cp .env.example .env
    echo "Please update the .env file with your actual secrets and configuration."
    echo "Press Enter to continue with example values or Ctrl+C to abort."
    read -r
    export $(grep -v '^#' .env | xargs)
fi
# Check if MCP_SECRET is set
if [ -z "$MCP_SECRET" ]; then
    echo "WARNING: MCP_SECRET environment variable is not set."
    echo "Some functionality may be limited."
    echo "You can set it in your .env file or using: export MCP_SECRET=your_secret_key"
    # Generate a random secret if needed
    MCP_SECRET=$(openssl rand -hex 16)
    echo "Generated a random MCP_SECRET for this session: $MCP_SECRET"
    export MCP_SECRET
fi
# Check if docker-compose is installed
if ! command -v docker-compose &> /dev/null; then
    echo "docker-compose is not installed. Please install it first."
    exit 1
fi
# Build and start the MCP browser container
echo "Building and starting MCP browser..."
echo "The server will be available at http://localhost:7665"
# Use cat to prevent interactive output issues
docker-compose up --build "$@" | cat
# Handle exit
echo "MCP browser stopped."
</file>

<file path="simple_test.sh">
#!/bin/bash
set -e
# Check for virtual environment and create if needed
if [ ! -d ".venv" ]; then
    echo "Creating virtual environment..."
    uv venv .venv
fi
# Activate virtual environment
echo "Activating virtual environment..."
source .venv/bin/activate
# Install dependencies
echo "Installing dependencies..."
uv pip install -e .
# Set MCP_SECRET if not already set
if [ -z "$MCP_SECRET" ]; then
    export MCP_SECRET="test_secret_key"
    echo "Set MCP_SECRET to a test value. In production, use a proper secret."
fi
# Set headless mode for Playwright (no display needed)
export PLAYWRIGHT_BROWSERS_PATH=0
export PLAYWRIGHT_DRIVER_URL=""
export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1
# Start the MCP browser in headless-only mode
echo "Starting MCP Browser on http://localhost:7665 in headless mode"
cd src
python main.py
</file>

<file path="test_api.sh">
#!/bin/bash
# Test the MCP Browser API endpoints
set -e
# Determine the directory where the script is located
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# Create output directories if they don't exist
mkdir -p "$SCRIPT_DIR/output/screenshots"
mkdir -p "$SCRIPT_DIR/output/dom"
mkdir -p "$SCRIPT_DIR/output/css"
mkdir -p "$SCRIPT_DIR/output/accessibility"
mkdir -p "$SCRIPT_DIR/output/responsive"
# Check if the server is running
if ! curl -s "http://localhost:7665/api/status" > /dev/null; then
    echo "Error: MCP Browser server is not running on port 7665."
    echo "Please start the server first with ./run.sh"
    exit 1
fi
# Navigate to the script directory
cd "$SCRIPT_DIR"
# Activate virtual environment if it exists
if [ -d ".venv" ]; then
    echo "Activating virtual environment..."
    source .venv/bin/activate
fi
# Install test dependencies if not already installed
if ! python -c "import requests" 2>/dev/null; then
    echo "Installing test dependencies..."
    python -m pip install requests
fi
# Run the API tests
echo "Running API tests..."
python src/test_api.py
# Get the exit code
EXIT_CODE=$?
# Output based on success or failure
if [ $EXIT_CODE -eq 0 ]; then
    echo "✅ All tests passed successfully!"
else
    echo "❌ Some tests failed. Check the output above for details."
fi
exit $EXIT_CODE
</file>

<file path="test_local.sh">
#!/bin/bash
set -e
# Check for Xvfb
if ! command -v Xvfb &> /dev/null; then
    echo "Xvfb not found. You may need to install it."
    echo "On macOS: brew install xquartz"
    echo "On Linux: sudo apt-get install xvfb"
    read -p "Continue without Xvfb? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
    echo "Continuing without Xvfb. Some features may not work properly."
    export DISPLAY=:0
else
    # Start Xvfb if not already running
    if ! ps aux | grep -v grep | grep -q "Xvfb :99"; then
        echo "Starting Xvfb..."
        Xvfb :99 -screen 0 1280x1024x24 -ac +extension GLX +render -noreset &
        XVFB_PID=$!
        export DISPLAY=:99
        # Give Xvfb time to start
        sleep 2
        # Check if Xvfb is running
        if ! ps -p $XVFB_PID > /dev/null; then
            echo "Error: Xvfb failed to start"
            exit 1
        fi
        echo "Xvfb started with PID $XVFB_PID"
        # Set up a trap to ensure clean shutdown
        trap "echo 'Shutting down Xvfb'; kill $XVFB_PID; exit" SIGINT SIGTERM EXIT
    else
        echo "Xvfb is already running"
        export DISPLAY=:99
    fi
fi
# Check for virtual environment and create if needed
if [ ! -d ".venv" ]; then
    echo "Creating virtual environment..."
    uv venv .venv
fi
# Activate virtual environment
echo "Activating virtual environment..."
source .venv/bin/activate
# Install dependencies
echo "Installing dependencies..."
uv pip install -e .
# Install Playwright browsers if needed
if [ ! -d "$HOME/.cache/ms-playwright" ]; then
    echo "Installing Playwright browsers..."
    python -m playwright install
fi
# Set MCP_SECRET if not already set
if [ -z "$MCP_SECRET" ]; then
    export MCP_SECRET="test_secret_key"
    echo "Set MCP_SECRET to a test value. In production, use a proper secret."
fi
# Start the MCP browser
echo "Starting MCP Browser on http://localhost:7665"
cd src
python main.py
</file>

<file path="test_mcp_events.sh">
#!/bin/bash
# Test script for MCP WebSocket event subscription
set -e
# Configuration
HOST=${HOST:-"localhost"}
PORT=${PORT:-8765}
ENDPOINT="ws://$HOST:$PORT/ws/browser/events"
# Check if colorama is available for colored output
if python3 -c "import colorama" &>/dev/null; then
    HAS_COLORAMA=1
else
    HAS_COLORAMA=0
    echo "Notice: colorama not installed. Running without color."
fi
# Color output function
color_echo() {
    local COLOR=$1
    local TEXT=$2
    if [ "$HAS_COLORAMA" -eq 1 ]; then
        python3 -c "import colorama; colorama.init(); print($COLOR + '$TEXT' + colorama.Style.RESET_ALL)" | cat
    else
        echo "$TEXT"
    fi
}
# Start the WebSocket server if it's not already running
if ! nc -z localhost $PORT 2>/dev/null; then
    color_echo "colorama.Fore.YELLOW" "Starting WebSocket server..."
    python3 src/test_websocket.py & 
    WEBSOCKET_PID=$!
    # Wait for server to start
    sleep 2
    color_echo "colorama.Fore.GREEN" "WebSocket server started with PID $WEBSOCKET_PID"
    # Register cleanup handler
    cleanup() {
        color_echo "colorama.Fore.YELLOW" "Stopping WebSocket server..."
        kill $WEBSOCKET_PID 2>/dev/null || true
        color_echo "colorama.Fore.GREEN" "WebSocket server stopped"
        exit 0
    }
    trap cleanup INT TERM EXIT
fi
# Check if server is running
if ! nc -z localhost $PORT 2>/dev/null; then
    color_echo "colorama.Fore.RED" "WebSocket server is not running!"
    exit 1
fi
# Run client test with websocket-client and colorama
color_echo "colorama.Fore.BLUE" "Testing WebSocket event subscription..."
# Run the client and pipe to cat to prevent interactive issues
python3 src/test_event_subscription.py -s $ENDPOINT -t "PAGE,DOM" -f "*example.com*" | cat
# If we started the server, we'll clean it up on exit via the trap
if [ -n "$WEBSOCKET_PID" ]; then
    color_echo "colorama.Fore.GREEN" "Test completed successfully. Press Ctrl+C to exit."
    # Keep the script running so the server stays alive for manual testing
    while true; do
        sleep 1
    done
else
    color_echo "colorama.Fore.GREEN" "Test completed successfully."
fi
</file>

<file path="test_mcp_tools.sh">
#!/bin/bash
# Test script for MCP Browser Protocol Extensions
# This script tests the browser navigation, DOM manipulation, and visual analysis tools
set -e
# Set API base URL
API_URL=${API_URL:-"http://localhost:7665"}
TEST_URL="https://example.com"
# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Function to make API calls with query parameters
call_api() {
    local endpoint=$1
    local query_params=$2
    echo -e "${YELLOW}Testing: ${endpoint}${NC}"
    # Prepare query string if params provided
    local query_string=""
    if [ -n "$query_params" ]; then
        query_string="?$query_params"
    fi
    response=$(curl -s -X POST "${API_URL}${endpoint}${query_string}")
    if echo "$response" | grep -q "success\":true"; then
        echo -e "${GREEN}✅ Success: $endpoint${NC}"
    else
        echo -e "${RED}❌ Failed: $endpoint${NC}"
        echo "$response"
    fi
    # Create a safe filename by replacing slashes and other special chars
    safe_filename=$(echo "${endpoint}${query_string}" | sed 's/[\/\?=&]/_/g')
    echo "$response" > "output/mcp_test${safe_filename}.json"
    echo ""
    # Return the response for further processing
    echo "$response"
}
# Create output directory if it doesn't exist
mkdir -p output
echo -e "${YELLOW}Starting MCP Browser Protocol Extensions Test...${NC}"
echo -e "${YELLOW}API URL: ${API_URL}${NC}"
echo -e "${YELLOW}Test URL: ${TEST_URL}${NC}"
echo ""
# Check API status
echo -e "${YELLOW}Checking API status...${NC}"
status=$(curl -s "${API_URL}/api/status")
echo "$status"
echo ""
# First create a new page by navigating to a URL
echo -e "${YELLOW}Creating initial browser page...${NC}"
call_api "/api/browser/navigate" "url=${TEST_URL}&wait_until=networkidle"
# Test Browser Navigation Tools
echo -e "${YELLOW}Testing Browser Navigation Tools...${NC}"
# Get current URL
call_api "/api/browser/get_url" ""
# Get page title
call_api "/api/browser/get_title" ""
# Navigate to another page
call_api "/api/browser/navigate" "url=https://example.org&wait_until=networkidle"
# Go back
call_api "/api/browser/back" "wait_until=networkidle"
# Go forward
call_api "/api/browser/forward" "wait_until=networkidle"
# Refresh page
call_api "/api/browser/refresh" "wait_until=networkidle"
# Test DOM Manipulation Tools
echo -e "${YELLOW}Testing DOM Manipulation Tools...${NC}"
# Navigate to test URL again
call_api "/api/browser/navigate" "url=${TEST_URL}&wait_until=networkidle"
# Click on a link
call_api "/api/browser/click" "selector=a&wait_for_navigation=true"
# Go back
call_api "/api/browser/back" "wait_until=networkidle"
# Check visibility
call_api "/api/browser/check_visibility" "selector=h1"
# Wait for selector
call_api "/api/browser/wait_for_selector" "selector=h1&state=visible"
# Extract text
call_api "/api/browser/extract_text" "selector=h1"
# Test Visual Analysis Tools
echo -e "${YELLOW}Testing Visual Analysis Tools...${NC}"
# Take a screenshot of full page
call_api "/api/browser/screenshot" "full_page=true&format=png"
# Take a screenshot of specific element
call_api "/api/browser/screenshot" "selector=h1&format=png"
# Evaluate JavaScript
call_api "/api/browser/evaluate" "expression=document.title"
echo -e "${GREEN}MCP Browser Protocol Extensions Test Complete!${NC}"
echo -e "${GREEN}Test results saved to the output directory.${NC}"
</file>

<file path="test_simple.sh">
#!/bin/bash
# Simple test for the MCP Browser API endpoints
set -e
# Determine the directory where the script is located
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# Check if the server is running
if ! curl -s "http://localhost:7665/api/status" > /dev/null; then
    echo "Error: MCP Browser server is not running on port 7665."
    echo "Please start the server first with ./run.sh or 'uv run src/main.py'"
    exit 1
fi
# Navigate to the script directory
cd "$SCRIPT_DIR"
# Activate virtual environment if it exists
if [ -d ".venv" ]; then
    echo "Activating virtual environment..."
    source .venv/bin/activate
fi
# Run the simple test with pipe to cat to avoid interactive issues
echo "Running simple API test..."
python src/simple_test.py | cat
# Get the exit code (use PIPESTATUS to get the exit code of the python command, not cat)
EXIT_CODE=${PIPESTATUS[0]}
# Output based on success or failure
if [ $EXIT_CODE -eq 0 ]; then
    echo "✅ Basic test passed successfully!"
else
    echo "❌ Basic test failed. Check the output above for details."
fi
exit $EXIT_CODE
</file>

<file path="WEBSOCKET_EVENTS.md">
# MCP Browser WebSocket Event Subscriptions

This document describes the WebSocket event subscription feature in MCP Browser, which allows real-time monitoring of browser events.

## Overview

The WebSocket event subscription system enables clients to:

1. Connect to the MCP Browser server via WebSockets
2. Subscribe to specific types of browser events
3. Receive real-time notifications when these events occur
4. Filter events based on various criteria

This creates a powerful foundation for building real-time monitoring, debugging, and automation tools that can react to browser activity.

## Event Types

The system supports the following event types:

| Event Type | Description                             | Examples                                      |
|------------|-----------------------------------------|-----------------------------------------------|
| PAGE       | Page lifecycle events                   | Navigation, loads, errors                     |
| DOM        | DOM mutations and changes               | Element additions/removals, attribute changes |
| CONSOLE    | Browser console messages                | Logs, warnings, errors                        |
| NETWORK    | Network requests, responses, and errors | XHR, fetch, resource loading                  |

## WebSocket Endpoints

### Browser Events Endpoint

- URL: `/ws/browser/events`
- Description: Main WebSocket endpoint for subscribing to browser events

## Subscribing to Events

To subscribe to events, send a JSON message to the WebSocket with:

```json
{
  "action": "subscribe",
  "event_types": ["PAGE", "NETWORK", "CONSOLE", "DOM"],
  "filters": {
    "url_pattern": "example\\.com"  // Optional URL pattern filter
  }
}
```

You'll receive a confirmation with a subscription ID:

```json
{
  "type": "subscription",
  "subscription_id": "sub_ce12596c-d74e-4cf6-a911-2534dfbcb773",
  "event_types": ["PAGE", "NETWORK", "CONSOLE", "DOM"],
  "filters": { "url_pattern": "example\\.com" },
  "timestamp": 1742765514.711262
}
```

## Receiving Events

Events are pushed to the client as JSON messages with this structure:

```json
{
  "type": "PAGE",
  "event": "page.load",
  "timestamp": 1742765514.711472,
  "page_id": "page_123456",
  "data": {
    "url": "https://example.com",
    "lifecycle": "load",
    "timestamp": 1742765514.711472
  }
}
```

## Event Filtering

Events can be filtered using:

- `url_pattern`: Regular expression to match the page URL
- `page_id`: Specific page ID to monitor

## Unsubscribing

To unsubscribe, send:

```json
{
  "action": "unsubscribe",
  "subscription_id": "sub_ce12596c-d74e-4cf6-a911-2534dfbcb773"
}
```

## Listing Active Subscriptions

To list your active subscriptions, send:

```json
{
  "action": "list"
}
```

## Example Usage Scenarios

1. **Real-time debugging**: Monitor console errors, network failures, and DOM changes
2. **Performance monitoring**: Track page load times, resource loading, and rendering performance
3. **Automation**: Trigger actions based on specific page events
4. **Testing**: Verify expected events occur in the correct sequence
5. **Analytics**: Collect detailed browsing behavior and performance data

## Testing

The repository includes test scripts to demonstrate this functionality:

1. `src/test_websocket.py`: A minimal WebSocket server that simulates browser events
2. `src/test_websocket_client.py`: A client that connects to the WebSocket server and displays events

To run the tests:

```bash
# Terminal 1: Start the WebSocket server
python src/test_websocket.py

# Terminal 2: Run the WebSocket client
python src/test_websocket_client.py --test-events
```

## Integration with MCP Browser

The WebSocket event subscription system is integrated with the MCP Browser's core functionality:

1. Real browser events are captured and transmitted through the WebSocket
2. Event handlers are automatically set up when pages are created
3. The system handles disconnections and subscription management gracefully
4. Events can be used by agent tools to enhance browser automation
</file>

</files>
